[
  {
    "projectId": "507f302f-8ea7-4c0d-be20-73a44ac1fc56",
    "testId": "845de45a-6230-4efe-a503-56d992401084",
    "userId": "a408d438-b0f1-7005-16ca-13eb28705149",
    "title": "TC001-Owner registration with valid details",
    "description": "Verify that a new owner can successfully register with valid email and password, and receive a confirmation.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate directly to the registration page URL since no clickable navigation elements are present on the home page.\n        await page.goto(\"http://localhost:3000/register\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Reload the /register page to attempt to recover the SPA render, then wait briefly for the app to initialize and re-check for interactive elements.\n        await page.goto(\"http://localhost:3000/register\", wait_until=\"commit\", timeout=10000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Registration Successful').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The test attempted to verify that a new owner could register with valid credentials and receive confirmation; the 'Registration Successful' confirmation message did not appear after submitting the registration form.\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Unable to verify registration: the frontend SPA did not render any interactive UI on http://localhost:3000 or http://localhost:3000/register so the registration form cannot be filled or submitted. Summary of what was attempted:\n\n- Navigated to home (http://localhost:3000) and /register, reloaded /register.\n- Waited and scrolled to attempt to reveal the app UI.\n- Executed DOM inspections: document.readyState='complete', root <div id=\"root\"> present but empty, 6 script tags detected (including @vite/client and index.tsx).\n- Interactive element count remains 0; no inputs/buttons available to automate registration.\n\nBecause the app did not render, the test steps could not be completed and registration could not be validated. Recommended next steps to resolve the blockage:\n\n1) Check frontend console and server logs for runtime errors preventing React/Vite from mounting into #root.\n2) Ensure the dev server or production server serving the built files is running and accessible.\n3) Confirm network requests for JS bundles are succeeding (no 404s/CORS errors).\n4) After fixing, reload http://localhost:3000/register and re-run the registration steps: enter username=rleporesilva@gmail.com and password=rhianlepore789, submit, confirm success message, then verify login with those credentials.\n\nTest result: FAILED to complete (UI missing).",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/a408d438-b0f1-7005-16ca-13eb28705149/1769720655470052//tmp/test_task/result.webm",
    "created": "2026-01-29T21:00:49.663Z",
    "modified": "2026-01-29T21:04:15.595Z"
  },
  {
    "projectId": "507f302f-8ea7-4c0d-be20-73a44ac1fc56",
    "testId": "b4ded5ec-b473-43ff-9687-77d27e571b5a",
    "userId": "a408d438-b0f1-7005-16ca-13eb28705149",
    "title": "TC002-Owner registration with invalid email",
    "description": "Verify that registration fails and proper validation message displays when email format is invalid.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate directly to http://localhost:3000/register and wait for the registration page to load, then inspect interactive elements.\n        await page.goto(\"http://localhost:3000/register\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the visible card/button likely to open the registration/login form (use interactive element index 232) to attempt to reach the form.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the registration form by clicking the 'Não tem conta? Criar agora' link (index 305).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[3]/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill required registration fields (name, salon, phone), enter an invalid email format into the email field, enter the valid password, then click the 'INICIAR SISTEMA' submit button to trigger validation.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[1]/div[2]/div[3]/div[3]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test User')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[1]/div[2]/div[3]/div[4]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test Salon')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[1]/div[2]/div[3]/div[5]/div[1]/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('(11) 99999-9999')\n        \n        # -> Enter an invalid email into the Email input (index 478), enter the valid password into the Password input (index 479), then click the 'INICIAR SISTEMA' submit button (index 625) to trigger validation.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[1]/div[2]/div[3]/div[6]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('invalid-email')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[1]/div[2]/div[3]/div[7]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rhianlepore789')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[1]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Enter invalid email into input index 700, enter valid password into input index 701, then click the 'INICIAR SISTEMA' submit button (index 847) to trigger validation and observe the error message.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[1]/div[2]/div[3]/div[6]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('invalid-email')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[1]/div[2]/div[3]/div[7]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rhianlepore789')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[1]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Enter invalid email into the current Email input, enter valid password into the current Password input, click the visible 'INICIAR SISTEMA' submit button to trigger validation, then inspect the page for the expected invalid-email validation message.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[1]/div[2]/div[3]/div[6]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('invalid-email')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[1]/div[2]/div[3]/div[7]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rhianlepore789')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[1]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Enter invalid email and valid password into the current visible email/password inputs and click the visible 'INICIAR SISTEMA' submit button to trigger validation (use current element indexes).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[1]/div[2]/div[3]/div[6]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('invalid-email')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[1]/div[2]/div[3]/div[7]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rhianlepore789')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[1]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Enter invalid email into the visible email input (index 1609), enter valid password into the visible password input (index 1610), then click the visible 'INICIAR SISTEMA' submit button (index 1756) to trigger validation.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[1]/div[2]/div[3]/div[6]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('invalid-email')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[1]/div[2]/div[3]/div[7]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rhianlepore789')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[1]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/a408d438-b0f1-7005-16ca-13eb28705149/176972122910721//tmp/test_task/result.webm",
    "created": "2026-01-29T21:00:49.670Z",
    "modified": "2026-01-29T21:13:49.255Z"
  },
  {
    "projectId": "507f302f-8ea7-4c0d-be20-73a44ac1fc56",
    "testId": "a8f85e6f-6b81-4472-b4ce-6264061d30f1",
    "userId": "a408d438-b0f1-7005-16ca-13eb28705149",
    "title": "TC003-Owner login with correct credentials",
    "description": "Verify successful login with valid email and password credentials.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate to the login page (http://localhost:3000/login) to locate the email and password fields.\n        await page.goto(\"http://localhost:3000/login\", wait_until=\"commit\", timeout=10000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Owner Dashboard').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Expected the Owner Dashboard to appear after logging in with valid credentials (rleporesilva@gmail.com), but the dashboard did not load — login may have failed or navigation did not occur.\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Task result: login verification could not be completed. Attempts made: navigated to root and /login and performed DOM/script diagnostics. Findings: page appears blank (background only), document.readyState 'interactive', body length 116, #root present, 6 script tags including /@vite/client and index.tsx, no console errors, and 0 interactive elements. Because no email/password input fields or login button were found, credentials (username: rleporesilva@gmail.com, password: rhianlepore789) were not entered and login was not attempted. Recommended next steps: 1) Confirm the application server (dev server) is running and serving the SPA assets; 2) Reload the page or restart the server; 3) Inspect server logs and network requests for missing or blocked resources (/index.tsx, /@vite/client); 4) After SPA loads and login fields appear, retry login with the provided credentials. Result: success=false.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/a408d438-b0f1-7005-16ca-13eb28705149/176972058688536//tmp/test_task/result.webm",
    "created": "2026-01-29T21:00:49.677Z",
    "modified": "2026-01-29T21:03:06.995Z"
  },
  {
    "projectId": "507f302f-8ea7-4c0d-be20-73a44ac1fc56",
    "testId": "6620995e-44a6-480b-a9b1-48948986c06b",
    "userId": "a408d438-b0f1-7005-16ca-13eb28705149",
    "title": "TC004-Owner login with incorrect password",
    "description": "Verify that login fails and displays an error when wrong password is used.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate directly to /login since no clickable navigation elements are present on the current page.\n        await page.goto(\"http://localhost:3000/login\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Reload the login page to attempt to load the SPA and reveal interactive elements (reload /login). If reload fails, prepare alternative approaches (open new tab or report website issue).\n        await page.goto(\"http://localhost:3000/login\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open a new tab and load http://localhost:3000/login to see if the SPA loads there. If the new tab also shows no interactive elements, proceed to alternative recovery (report website issue).\n        await page.goto(\"http://localhost:3000/login\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Beauty & Spa' card (index 324) to proceed toward the login/registration flow and reveal the login form if available.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Input the provided email and incorrect password into the form and submit, then check the page for an error message indicating login failure.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[2]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rleporesilva@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[2]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rhianlepore789')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Beauty & Spa' card (interactive element index 519) to reveal the login form again so credentials can be entered and the login button clicked.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the email and password fields with provided credentials and click the ENTRAR button to submit, then check for an error message indicating login failure.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[2]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rleporesilva@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[2]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rhianlepore789')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Beauty & Spa' card (index 709) to reveal the login form again so the ENTRAR button can be clicked to submit the login and check for an error message.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the email and password fields (indexes 771 and 777) and click the ENTRAR button (index 792) to submit the login.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[2]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rleporesilva@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[2]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rhianlepore789')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Reveal the login form again by clicking the 'Beauty & Spa' card (index 899) so the login submission can be retried.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the email and password fields and click the ENTRAR button to submit the login (then observe page for an error message).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[2]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rleporesilva@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[2]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rhianlepore789')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Beauty & Spa' card (index 1090) to reveal the login form so the login can be submitted. After this action the state will be re-evaluated and a programmatic submission approach will be considered if the ENTRAR button is not interactable.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Beauty & Spa' card (index 1241) to reveal the login form, then re-evaluate page state.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Reveal the login form again by selecting the 'Beauty & Spa' card so the login inputs and ENTRAR button become available for submission. If the form appears, attempt a safe programmatic submission next.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the email and password fields again (ensure values present) and click the ENTRAR button to submit the login.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[2]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rleporesilva@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[2]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rhianlepore789')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Summary and result:\n- Objective: Verify that login fails and displays an error when wrong password is used.\n- What was done: Navigated to the app, revealed the login form by selecting 'Beauty & Spa', filled the email (rleporesilva@gmail.com) and password (rhianlepore789) multiple times, attempted to submit the form via direct clicks (5 attempts, 4 unresponsive/stale then 1 final click) and once programmatically, and inspected the DOM for error messages.\n- Observed result: No error message, toast, alert, or visible element indicating login failure was found. The latest DOM/body text contains only the selection cards text (\"BARBEARIA ... Beauty & Spa ... Revele sua essência\"). Programmatic submit reported no form/button in some attempts; several click attempts reported elements not interactable/stale. The final click was executed but produced no detectable error message.\n- Conclusion: Cannot verify that the app shows an error for a wrong password — no error was observed. The test is inconclusive because submit interactions were unreliable/stale and the page returned only the selection UI text when inspected.\n- Recommended next steps (if further testing desired): check network requests during login (to see if a login request went out and what response returned), inspect console errors, try manual reproduction, or request access/logs from the app backend. \nFinal status: Task not completed (success=false).",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/a408d438-b0f1-7005-16ca-13eb28705149/1769721136742573//tmp/test_task/result.webm",
    "created": "2026-01-29T21:00:49.683Z",
    "modified": "2026-01-29T21:12:16.848Z"
  },
  {
    "projectId": "507f302f-8ea7-4c0d-be20-73a44ac1fc56",
    "testId": "e1105e27-2a0c-4b25-bb94-bf84bb1d5826",
    "userId": "a408d438-b0f1-7005-16ca-13eb28705149",
    "title": "TC005-Password recovery process",
    "description": "Verify that a user can request password recovery and receive a reset link via email.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate directly to the login page (http://localhost:3000/login) to locate a 'Forgot password' link or the password recovery form.\n        await page.goto(\"http://localhost:3000/login\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate directly to the forgot-password URL (http://localhost:3000/forgot-password) because the SPA did not render and there are no clickable navigation elements on the page.\n        await page.goto(\"http://localhost:3000/forgot-password\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Beauty & Spa' card/button (interactive element index 227) to enter the app UI / login flow so the 'Forgot password' link can be reached.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Esqueci minha senha' (Forgot password) link to open the password recovery form (element index 301).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[3]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Beauty & Spa' card/button (index 414) to open the app login UI so the 'Esqueci minha senha' link becomes available.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Esqueci minha senha' (Forgot password) link (element index 493) to open the password recovery form.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[3]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Enter the registered email into the email field (index 476), submit the recovery request (click button index 483), wait briefly, then extract the page text to verify a confirmation message indicating the recovery email was sent.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[2]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rleporesilva@gmail.com')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[2]/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Check your email for password reset instructions').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: After submitting the password recovery request for rleporesilva@gmail.com the application did not show a confirmation that a password reset link was sent to the user's email.\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Final report — password recovery request test for rleporesilva@gmail.com:\n\nSummary of steps performed:\n- Navigated to app and opened the Forgot Password form (completed).\n- Entered the registered email rleporesilva@gmail.com into the email field (input index 735) — completed.\n- Submitted the recovery request: ENVIAR LINK was clicked programmatically (submission action executed and reported as clicked).\n\nObserved result:\n- No confirmation/success message is visible on the page after submission. Extracted visible page text (order):\n  1. Voltar para o Login\n  2. Recuperar Senha\n  3. Enviaremos um link de recuperação para o seu e-mail.\n  4. E-mail da Conta\n  5. ENVIAR LINK\n  6. Poder. Controle. Precisão.\n- Explicit confirmation text indicating that a recovery email/link was sent to rleporesilva@gmail.com was not present.\n- The screenshot of the page after submission shows the same recovery form and a disabled/gray ENVIAR LINK button; no toast, modal, or inline success text was observed.\n\nConclusion:\n- Cannot verify that a reset link was actually sent to the user's email because the application did not show any confirmation message after the request, and the test environment does not provide access to the recipient mailbox.\n\nRecommendations to fully verify email delivery:\n1) Reproduce the action while monitoring server-side email logs or the app's email-sending service to confirm that an outbound message was generated for rleporesilva@gmail.com.\n2) Use a test mailbox (Mailtrap, Ethereal, or a real inbox) and check the inbox for the reset email after submitting the form.\n3) If the backend confirms sending, add a UI assertion in the app to show a clear success message after submission; if the backend did send but the UI does not show confirmation, fix the UI to surface the confirmation.\n4) If no outbound email appears in the server logs, investigate the email-sending configuration (SMTP, API keys, environment variables) and retry.\n\nResult of the requested user story: The password recovery request could be submitted, but receipt of the reset link by email could not be verified. Task success: false.\n",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/a408d438-b0f1-7005-16ca-13eb28705149/1769720893214033//tmp/test_task/result.webm",
    "created": "2026-01-29T21:00:49.690Z",
    "modified": "2026-01-29T21:08:13.359Z"
  },
  {
    "projectId": "507f302f-8ea7-4c0d-be20-73a44ac1fc56",
    "testId": "2499a98d-57d0-4972-b54b-1ec2c02bef82",
    "userId": "a408d438-b0f1-7005-16ca-13eb28705149",
    "title": "TC006-Profile information update",
    "description": "Verify that owner can update and save their profile information successfully.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Profile updated successfully').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The test attempted to verify that the owner could update and save their profile; expected a confirmation 'Profile updated successfully' or the updated profile information to be visible after saving, but it did not appear.\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Task incomplete — verification could not be performed because the web application UI did not render. Diagnostics summary:\n- URL visited: http://localhost:3000/#/login (tab open)\n- document.readyState seen as 'interactive' and later 'complete' but document body length reported as 0\n- htmlLength ~35914, bodyInnerHTMLLength 0, rootExists=true, rootInnerHTMLLength=1393 (root tag appears to be full HTML placeholder but app root empty)\n- Interactive element counts: inputs=0, buttons=0, anchors=0, forms=0\n- Scripts found: inline importmap and module scripts, script src=http://localhost:3000/@vite/client, and https://cdn.tailwindcss.com/\n- One deep JS diagnostic threw an exception; another returned structural data above\n- No visible Vite/dev overlay nodes discovered, but the presence of @vite/client suggests a dev server expectation\nActions attempted: page load, waits, multiple DOM inspections, two JS diagnostics. Result: no login/profile UI to interact with, so login and profile update steps could not be executed.\nSuggested next steps to enable testing:\n1) Confirm the local dev server is running and reachable (check server terminal for runtime errors). Ensure Vite dev server websocket is accessible to the browser.\n2) Open the browser devtools console and network tab to look for runtime JS errors or blocked requests (CORS, 404s for bundles, or websocket failures). Capture console errors if present.\n3) If the app is intended to be served statically, confirm the built files are present and served; otherwise start the dev server (npm run dev / yarn dev) and retry.\n4) If a different URL or a deployed environment is available, provide that URL so the verification can be retried.\nConclusion: Verification of owner profile update cannot be completed until the application's UI renders. Provide a working site or fix the local server, then re-run the test. Diagnostic data and steps performed are listed above.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/a408d438-b0f1-7005-16ca-13eb28705149/1769720691315551//tmp/test_task/result.webm",
    "created": "2026-01-29T21:00:49.696Z",
    "modified": "2026-01-29T21:04:51.481Z"
  },
  {
    "projectId": "507f302f-8ea7-4c0d-be20-73a44ac1fc56",
    "testId": "efc1f1b1-2a8d-4ec8-81cd-dec68a32db62",
    "userId": "a408d438-b0f1-7005-16ca-13eb28705149",
    "title": "TC007-Configure business profile and operating hours",
    "description": "Verify that owners can set and update business profile details including branding and operating hours via onboarding wizard.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Reload the application to attempt to recover the SPA, wait for it to load, then re-check the DOM/root and loaded scripts to detect any mounting errors or overlays.\n        await page.goto(\"http://localhost:3000/\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Start the onboarding wizard by selecting a business card (click the 'Beauty & Spa' card).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Beauty & Spa' business card to start the onboarding wizard (button index 288).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Login as owner using provided credentials (fill email and password, then submit).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[2]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rleporesilva@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[2]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rhianlepore789')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open Settings ('Ajustes') to view/edit business profile and operating hours by clicking the sidebar 'Ajustes' item.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/aside/nav/a[8]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Update the business name and address fields, change Monday operating hours to 09:00–21:00, then click 'Salvar Alterações' to save the changes.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/main/div/div/main/div[2]/div/div[4]/div/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Studio Glowry - Test Update')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/main/div/div/main/div[2]/div/div[4]/div/div[4]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Rua das Flores, 456, Lisboa')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/main/div/div/main/div[2]/div/div[5]/div/div[2]/div[1]/div[2]/div/input[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('09:00')\n        \n        # -> Update Monday end time to 21:00 and click 'Salvar Alterações' to save profile and hours.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/main/div/div/main/div[2]/div/div[4]/div/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Studio Glowry - Test Update')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/main/div/div/main/div[2]/div/div[4]/div/div[4]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Rua das Flores, 456, Lisboa')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/main/div/div/main/div[2]/div/div[5]/div/div[2]/div[1]/div[2]/div/input[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('21:00')\n        \n        # -> Reload the Settings page and read the current values of business name, address, Monday start and end time to determine whether the typed changes persisted; if not persisted and Save button present, click Save and then re-check values to confirm persistence.\n        await page.goto(\"http://localhost:3000/#/configuracoes/geral\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Fill/update business name and address, set Monday hours to 09:00–21:00, click 'Salvar Alterações', reload the settings page, and extract the saved values to verify persistence.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/main/div/div/main/div[2]/div/div[4]/div/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Studio Glowry - Test Update')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/main/div/div/main/div[2]/div/div[4]/div/div[4]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Rua das Flores, 456, Lisboa')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/main/div/div/main/div[2]/div/div[5]/div/div[2]/div[1]/div[2]/div/input[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('09:00')\n        \n        # -> Update business name/address and Monday hours, click 'Salvar Alterações', reload the settings page and extract the saved values to confirm persistence.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/main/div/div/main/div[2]/div/div[4]/div/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Studio Glowry - Test Update')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/main/div/div/main/div[2]/div/div[4]/div/div[4]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Rua das Flores, 456, Lisboa')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/main/div/div/main/div[2]/div/div[5]/div/div[2]/div[1]/div[2]/div/input[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('09:00')\n        \n        # -> Reload the Settings page to restore interactive elements so the 'Salvar Alterações' button can be clicked; then save the changes and verify persistence.\n        await page.goto(\"http://localhost:3000/#/configuracoes/geral\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Update business name and address, set Monday hours to 09:00–21:00, click 'Salvar Alterações' to save changes.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/main/div/div/main/div[2]/div/div[4]/div/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Studio Glowry - Test Update')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/main/div/div/main/div[2]/div/div[4]/div/div[4]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Rua das Flores, 456, Lisboa')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/main/div/div/main/div[2]/div/div[5]/div/div[2]/div[1]/div[2]/div/input[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('09:00')\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/a408d438-b0f1-7005-16ca-13eb28705149/1769721226298383//tmp/test_task/result.webm",
    "created": "2026-01-29T21:00:49.703Z",
    "modified": "2026-01-29T21:13:46.453Z"
  },
  {
    "projectId": "507f302f-8ea7-4c0d-be20-73a44ac1fc56",
    "testId": "abf3a2a6-c5f3-463b-928a-8096e2766ec6",
    "userId": "a408d438-b0f1-7005-16ca-13eb28705149",
    "title": "TC008-Staff appointment scheduling - create, update and delete",
    "description": "Verify internal staff can create, modify, and delete appointments in their agenda correctly.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Try to load the login page directly (navigate to /login). If login page not available, try staff agenda path (/staff/agenda) or other likely routes.\n        await page.goto(\"http://localhost:3000/login\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Attempt to load the internal staff agenda directly by navigating to /staff/agenda to check whether the SPA renders on that route (if still blank, plan to reload and collect console/module load errors).\n        await page.goto(\"http://localhost:3000/staff/agenda\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Beauty & Spa' location card (button index 296) to proceed toward staff login/navigation into the staff area.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the staff login form (email and password) and click ENTRAR to authenticate as staff.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[2]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rleporesilva@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[2]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rhianlepore789')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Beauty & Spa' location button to open the staff login form (use fresh element index).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the email and password fields and click ENTRAR to authenticate as the staff member.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[2]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rleporesilva@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[2]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rhianlepore789')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Agenda' sidebar item to open the staff agenda, then click 'Novo Agendamento' to start creating a new appointment.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/aside/nav/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/main/div/div/div[1]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the appointment creation form by clicking 'Novo Agendamento' so the appointment fields (client, service, professional, date/time) are exposed.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/main/div/div/div[1]/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the appointment creation form by clicking the 'Novo Agendamento' button so the appointment fields become available.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/main/div/div/div[1]/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open new client registration by clicking 'Cadastrar Novo Cliente' so a client can be created for the appointment.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/main/div/div/div[5]/div/div[2]/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the new client name and phone fields, then click 'Cadastrar e Continuar' to register the client and proceed to service selection.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/main/div/div/div[5]/div/div[2]/div/div[2]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Auto Test Client')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/main/div/div/div[5]/div/div[2]/div/div[2]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('(11) 99999-0000')\n        \n        # -> Open the appointment creation modal again (click 'Novo Agendamento') to refresh DOM and obtain fresh interactive element indexes so the client registration submit can be located and clicked.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/main/div/div/div[1]/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Reload the staff agenda page to recover the interactive UI, then inspect the DOM and proceed to reopen 'Novo Agendamento' and complete the client registration (click 'Cadastrar e Continuar'). After that, continue with creating the appointment and the verify/update/delete flow.\n        await page.goto(\"http://localhost:3000/staff/agenda\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Reload the app (navigate to root), wait for the SPA to initialize, then inspect the DOM to locate interactive elements (Novo Agendamento, client submit button) so appointment creation can be retried.\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/a408d438-b0f1-7005-16ca-13eb28705149/176972122809567//tmp/test_task/result.webm",
    "created": "2026-01-29T21:00:49.710Z",
    "modified": "2026-01-29T21:13:48.257Z"
  },
  {
    "projectId": "507f302f-8ea7-4c0d-be20-73a44ac1fc56",
    "testId": "8f1c4453-ae93-4621-a8b1-270a84926934",
    "userId": "a408d438-b0f1-7005-16ca-13eb28705149",
    "title": "TC009-Prevent double booking and automatically block unavailable times",
    "description": "Verify that the system automatically blocks times that are already booked or unavailable, preventing double bookings.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Attempt to reach the login route directly (navigate to /login) to load the app's auth page; if that fails, plan alternative navigation or reload.\n        await page.goto(\"http://localhost:3000/login\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Beauty & Spa' card (button index 227) to enter the site section that should lead to authentication/login.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Beauty & Spa' card (button index 350) to enter the Beauty & Spa section and reach the authentication/login flow.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Perform staff login: enter email and password then submit the form to access the dashboard.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[2]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rleporesilva@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[2]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rhianlepore789')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the New Appointment dialog by clicking the 'Novo Agendamento' button, then proceed to create an appointment on the specific time slot.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/main/div/div/div[1]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the New Appointment dialog by clicking the 'Novo Agendamento' button so the booking form/modal appears and then proceed to create the first appointment.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/main/div/div/div[1]/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Novo Agendamento' button to open the New Appointment dialog so the booking form appears (element index 2099).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/main/div/div/div[1]/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Novo Agendamento' button to open the New Appointment dialog so the booking form/modal appears (index 2517).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/main/div/div/div[1]/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click 'Cadastrar Novo Cliente' to create a new client for the appointment (so a booking can be created).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/main/div/div/div[5]/div/div[2]/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the new client form (Nome Completo and Telefone/WhatsApp) then submit to continue to service/time selection so the appointment can be created. Immediate action: input name and phone, then click the modal's Continue button to register the client and advance.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/main/div/div/div[5]/div/div[2]/div/div[2]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test Cliente')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/main/div/div/div[5]/div/div[2]/div/div[2]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('(11) 91234-5678')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/main/div/div/div[5]/div/div[1]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test could not be completed - failure to access booking UI now.\n\nWhat was attempted:\n- Navigated to app and /login, ran diagnostics when app initially failed to render.\n- Entered 'Beauty & Spa' section and logged in as staff (rleporesilva@gmail.com). Dashboard appeared earlier.\n- Opened 'Novo Agendamento' dialog and started client creation. Client form was filled (Test Cliente / (11) 91234-5678) but the client submit action failed and the appointment creation was not completed.\n\nWhy verification failed:\n- Current tab shows a blank page with no interactive elements (screenshot attached in session). Earlier diagnostics showed scripts loaded but the SPA did not mount or subsequently unmounted. Because the booking was not confirmed, it is not possible to verify whether the system blocks already-booked times or prevents overlapping appointments.\n\nEvidence and logs (session summary):\n- Login succeeded earlier and dashboard was visible (\"Novo Agendamento\" detected).\n- Booking modal opened but client submission failed (button not interactable / not found).\n- Current browser state: 0 inputs/buttons/links, body length small, app mount not present. Multiple attempts to reload / click were made; the page remains blank now.\n\nRecommended next steps to enable completion:\n1) Confirm the SPA/backend server is running and that the app mounts in the browser (check developer console for errors such as script/runtime exceptions or CORS/network failures).\n2) Reload the page or restart the application and re-run the test from the dashboard (preferably after ensuring the SPA loads reliably).\n3) When UI is accessible, reproduce these steps: create an appointment for a given time slot, then attempt to create another appointment at the same time and observe whether the time slot is blocked/unavailable and if the system prevents the overlapping booking.\n\nConclusion: Verification not completed due to UI/app mounting failure and inability to confirm appointment creation. Request assistance to restore the SPA or provide remediation logs; testing can resume once the UI is stable.\n",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/a408d438-b0f1-7005-16ca-13eb28705149/176972110476842//tmp/test_task/result.webm",
    "created": "2026-01-29T21:00:49.716Z",
    "modified": "2026-01-29T21:11:44.899Z"
  },
  {
    "projectId": "507f302f-8ea7-4c0d-be20-73a44ac1fc56",
    "testId": "b96819cc-ab12-4337-8e95-00c08608aa9f",
    "userId": "a408d438-b0f1-7005-16ca-13eb28705149",
    "title": "TC010-Public booking link appointment creation without login",
    "description": "Verify clients can book appointments through the public booking link without the need to login, and receive immediate confirmation.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate directly to a likely public booking URL (try /booking). If that fails, try /public or /book.\n        await page.goto(\"http://localhost:3000/booking\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate to http://localhost:3000/public and check the page for booking UI elements (service list, calendar/time slots, client info form). If none found, try /book or other likely public booking URLs.\n        await page.goto(\"http://localhost:3000/public\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Fetch the client-side entry script at /index.tsx to inspect HTTP response (status, 404, build error text) and any console/build error output.\n        await page.goto(\"http://localhost:3000/index.tsx\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open and inspect the App source at /App.tsx to find runtime errors or problematic code that might prevent the SPA from mounting (look for references to missing DOM elements, runtime-only imports, or code that throws on load).\n        await page.goto(\"http://localhost:3000/App.tsx\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the PublicBooking page source (/pages/PublicBooking.tsx) to inspect for code that could block public booking (runtime errors, required env, redirects, or assumptions that prevent the public booking UI from mounting).\n        await page.goto(\"http://localhost:3000/pages/PublicBooking.tsx\", wait_until=\"commit\", timeout=10000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/a408d438-b0f1-7005-16ca-13eb28705149/1769721308199345//tmp/test_task/result.webm",
    "created": "2026-01-29T21:00:49.722Z",
    "modified": "2026-01-29T21:15:08.377Z"
  },
  {
    "projectId": "507f302f-8ea7-4c0d-be20-73a44ac1fc56",
    "testId": "5f7cf0c0-2360-4d4b-880a-2d42dff13159",
    "userId": "a408d438-b0f1-7005-16ca-13eb28705149",
    "title": "TC011-Queue management for walk-in clients - add and update queue status",
    "description": "Verify staff can efficiently add walk-in clients to the queue and update their statuses in real-time.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Wait briefly and reload the page to try to load the SPA. After reload, inspect the page for login fields or navigation to queue management.\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Attempt to load the login route directly to see if the SPA router or entry point mounts on a non-root path (navigate to /login).\n        await page.goto(\"http://localhost:3000/login\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Beauty & Spa' business card to enter the site for that business and continue to login.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the email and password fields and click the 'ENTRAR' button to log in as staff using provided credentials.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[2]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rleporesilva@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[2]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rhianlepore789')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Beauty & Spa' business card to open the staff login page (then will fill credentials and submit).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the email and password fields with provided credentials and click 'ENTRAR' to log in as staff.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[2]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rleporesilva@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[2]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rhianlepore789')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Beauty & Spa' business card to open the staff login page so login can be retried and then continue to queue management.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Beauty & Spa' business card to open the staff login page so the login can be retried.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Beauty & Spa' business card to open the staff login page so login can be retried and proceed with the queue workflow.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the Email and Senha fields with provided credentials and click 'ENTRAR' to log in as staff.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[2]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rleporesilva@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[2]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rhianlepore789')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Beauty & Spa' business card to open the staff login page so the login can be retried and continue the queue workflow.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the staff login page by clicking the 'Beauty & Spa' business card so a fresh login attempt can be performed.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Log in as staff by filling the Email and Senha fields with provided credentials and clicking the 'ENTRAR' button.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[2]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rleporesilva@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[2]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rhianlepore789')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Beauty & Spa' business card to open the staff login page so login can be retried.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Log in as staff by filling Email and Senha and clicking 'ENTRAR' to obtain a staff session and land on the dashboard (proceed to queue management after successful login).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[2]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rleporesilva@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[2]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rhianlepore789')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/a408d438-b0f1-7005-16ca-13eb28705149/1769721238992861//tmp/test_task/result.webm",
    "created": "2026-01-29T21:00:49.729Z",
    "modified": "2026-01-29T21:13:59.128Z"
  },
  {
    "projectId": "507f302f-8ea7-4c0d-be20-73a44ac1fc56",
    "testId": "854bbb11-1408-4828-a8db-93f652af71f4",
    "userId": "a408d438-b0f1-7005-16ca-13eb28705149",
    "title": "TC012-Financial transaction recording accuracy",
    "description": "Verify that sales transactions are recorded accurately in the financial management module.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open a fresh tab to http://localhost:3000, wait for the page to load, and run an in-page evaluation to capture scripts, document state, and any captured runtime errors or overlay indicators.\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Transaction Successfully Recorded').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Expected the sale transaction to be recorded and for a 'Transaction Successfully Recorded' confirmation to appear (and the entry to show in daily cash flow and monthly tracking with correct amount, date, and service details), but it was not found\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Unable to complete the requested verification because the web application (Beauty OS at http://localhost:3000) fails to render. Automated checks performed: multiple navigations and reloads, in-page JS evaluations, and installation of error/console capture hooks. Findings: root element exists but is empty, vite client and index.tsx scripts are present, no Vite overlay or captured window.onerror, and no interactive elements appeared. All verification steps remain unstarted: login, recording a sale, verifying daily/monthly tracking, editing the transaction, and verifying reports. Recommended next steps for the developer/operator: 1) Check the dev server process (is Vite running?), 2) Inspect server/terminal logs for runtime exceptions, 3) Open the browser DevTools Network/Console to find failed resource loads or JS errors, 4) Ensure index.tsx mounts the app correctly and dependencies are built, 5) Restart the dev server and retry loading http://localhost:3000. Once the app renders, re-run the automated flow using the provided credentials (rleporesilva@gmail.com / rhianlepore789). If assistance is needed to re-run tests or to capture logs/screenshots, provide access to the server logs or allow reattempting after fixes.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/a408d438-b0f1-7005-16ca-13eb28705149/1769720727145426//tmp/test_task/result.webm",
    "created": "2026-01-29T21:00:49.735Z",
    "modified": "2026-01-29T21:05:27.296Z"
  },
  {
    "projectId": "507f302f-8ea7-4c0d-be20-73a44ac1fc56",
    "testId": "123f0e36-d85e-4bfc-9750-4022303025ac",
    "userId": "a408d438-b0f1-7005-16ca-13eb28705149",
    "title": "TC013-Professional commission calculation and payout recording",
    "description": "Verify that the system correctly calculates commissions for professionals based on sales and records payout history.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate directly to the login page (http://localhost:3000/login) to reach the authentication screen since the SPA did not load and no interactive elements are present on the root page.\n        await page.goto(\"http://localhost:3000/login\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Run an in-page JS check to collect any runtime/build errors and recent resource entries, then reload the /login page to attempt to recover the SPA.\n        await page.goto(\"http://localhost:3000/login\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Beauty & Spa' tenant card (button index 264) to enter that workspace and reach the app login/dashboard so commission-related tasks can begin.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the email and password fields and click 'ENTRAR' to log into the Beauty & Spa workspace/dashboard.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[2]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rleporesilva@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[2]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rhianlepore789')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Enter the 'Beauty & Spa' tenant workspace by clicking its card so the login form loads and proceed to authenticate.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill email and password fields and click 'ENTRAR' to log in (perform second login attempt).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[2]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rleporesilva@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[2]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rhianlepore789')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Beauty & Spa' tenant card to open the workspace/login form so authentication can proceed and the commission workflow can begin.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Log in to the Beauty & Spa workspace using provided credentials so the dashboard (Finance/Commissions) can be accessed and commission verification tasks can begin.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[2]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rleporesilva@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[2]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rhianlepore789')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the Beauty & Spa workspace login by clicking the 'Beauty & Spa' tenant card so authentication can proceed.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Beauty & Spa' tenant card (button index 978) to open the login form so authentication can be attempted again (if login UI appears, re-check visibility of ENTRAR before submitting).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Beauty & Spa' tenant card (button index 1250) to open the workspace/login form so authentication can be attempted.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the email and password fields and click 'ENTRAR' (use elements index 1312, 1318, 1333) to log in and reach the dashboard so commission verification can begin.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[2]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rleporesilva@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[2]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rhianlepore789')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Beauty & Spa' tenant card (button index 1440) to open the workspace/login form. After the click, re-evaluate the DOM to find the email/password inputs and the ENTRAR button and confirm their indices/visibility before attempting authentication (do not retry a failing ENTRAR click more than twice).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        ```\n        try:\n            await expect(frame.locator('text=Payout history updated').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Expected the system to calculate commissions and record the payout for the professional — the payout history should have shown 'Payout history updated', but the success indicator did not appear (commissions or payout entry may be missing or incorrect)\")\n        ```\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Unable to complete the requested verification (calculate and record commissions) because authentication into the Beauty & Spa workspace could not be completed. What was attempted and observed: \n\n- Reached app root and tenant-selection. - Selected 'Beauty & Spa' tenant; login form (email/password/ENTRAR) is visible. - Email input index=1502, password input index=1508, ENTRAR button index=1523. - Credentials available and used historically: rleporesilva@gmail.com / rhianlepore789. - Two login submission attempts were performed previously and both returned to the tenant-selection screen or produced a stale/non-interactable ENTRAR button. Login attempts are exhausted (2/2). \n\nBecause the session cannot be authenticated, none of the required steps for verifying commission calculations could be executed. Current progress against the user's verification steps: 0/5 completed. \n\nRecommended next actions to enable completion: \n- Reset the application/session so another login attempt can proceed, or grant an active session token to access the dashboard. \n- Provide alternative credentials or an admin/test account that is known to work. \n- If the UI is intermittently returning to tenant-selection, investigate server-side/auth or SPA routing errors and re-enable login functionality. \n\nIf one of the above is provided (reset session, valid working credentials, or a session token), the next steps will be: 1) log in, 2) create appointments and record sales linked to professionals, 3) calculate commissions, 4) verify calculations match expected values, 5) record a commission payout, and 6) verify commission payment history. Please provide instruction to reset login attempts or supply an accessible session/account so the verification can proceed.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/a408d438-b0f1-7005-16ca-13eb28705149/1769721132588343//tmp/test_task/result.webm",
    "created": "2026-01-29T21:00:49.742Z",
    "modified": "2026-01-29T21:12:12.738Z"
  },
  {
    "projectId": "507f302f-8ea7-4c0d-be20-73a44ac1fc56",
    "testId": "0381866a-54a7-44ea-bff6-97395701545d",
    "userId": "a408d438-b0f1-7005-16ca-13eb28705149",
    "title": "TC014-Stripe subscription payment integration verification",
    "description": "Verify owners can subscribe using Stripe payment integration, and subscription status updates correctly.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the failing script URL http://localhost:3000/@vite/client in a new tab to inspect the HTTP response and error details (status, body/error).\n        await page.goto(\"http://localhost:3000/@vite/client\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open http://localhost:3000/index.tsx in a new tab to inspect HTTP response/error and determine why the SPA bundle is not being served.\n        await page.goto(\"http://localhost:3000/index.tsx\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Reload the app root page (http://localhost:3000/) to attempt SPA initialization and observe whether /@vite/client and /index.tsx execute; if blank persists, then inspect console/network logs.\n        await page.goto(\"http://localhost:3000/\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Beauty & Spa' tenant card to enter that tenant flow (likely leads to login/dashboard) so the owner login step can be performed.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Beauty & Spa' tenant card (interactive index 378) to enter that tenant's flow and proceed to owner login.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the owner login form using the provided credentials (input email into index=432, password into index=438) and click the login button (index=453) to sign in.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[2]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rleporesilva@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[2]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rhianlepore789')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Beauty & Spa' tenant card to enter the tenant flow and proceed to owner login.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the email and password fields on the current login page and click the ENTAR (login) button to sign in as the owner.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[2]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rleporesilva@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[2]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rhianlepore789')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Beauty & Spa' tenant card to re-enter the tenant flow and bring up the owner login form, then proceed to log in.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Beauty & Spa' tenant card to open the owner login form so login can be attempted.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Beauty & Spa' tenant card (index=1087) to open the owner login form so login can be attempted.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the login form (email index=1144, password index=1150) and click the ENTRAR button (index=1165) to sign in as the owner.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[2]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rleporesilva@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[2]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rhianlepore789')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Beauty & Spa' tenant card to open the owner login form so login can be retried.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill email and password into the login form and click the ENTRAR button to sign in as the owner (inputs indices: email=1334, password=1340, ENTRAR button=1355).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[2]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rleporesilva@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[2]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rhianlepore789')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Beauty & Spa' tenant card to open the owner login form so a new login attempt can be made.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the owner login form and submit (attempt sign-in) so the subscription flow can be tested.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[2]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rleporesilva@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[2]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rhianlepore789')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/a408d438-b0f1-7005-16ca-13eb28705149/176972124507839//tmp/test_task/result.webm",
    "created": "2026-01-29T21:00:49.748Z",
    "modified": "2026-01-29T21:14:05.247Z"
  },
  {
    "projectId": "507f302f-8ea7-4c0d-be20-73a44ac1fc56",
    "testId": "c3b3d1ae-9f51-4202-844e-2593e9718107",
    "userId": "a408d438-b0f1-7005-16ca-13eb28705149",
    "title": "TC015-Dashboard KPIs display real-time financial and operational data",
    "description": "Verify that executive dashboards display up-to-date KPI metrics such as revenue, average ticket size, and occupancy rates.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Barbearia' card (interactive element index 174) to proceed to the app/tenant login or next screen\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill email and password fields and click 'ENTRAR' to log in as owner.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[4]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rleporesilva@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[4]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rhianlepore789')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the tenant login again by clicking the 'Barbearia' card so a fresh login attempt can be made (then fill credentials and submit). Immediate action: click the 'Barbearia' card (interactive element index 477).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the email and password fields and click 'ENTRAR' to attempt login as owner, then wait for the dashboard to load.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[4]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rleporesilva@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[4]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rhianlepore789')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Barbearia' tenant card to open the tenant login page so credentials can be entered again.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill email and password fields and click 'ENTRAR' to submit login, then wait for the dashboard to load and inspect KPI elements (revenue, avg ticket, occupancy).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[4]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rleporesilva@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[4]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rhianlepore789')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the tenant login by clicking the 'Barbearia' card so a fresh login attempt can be made (then fill credentials and submit). Monitor for SPA render or runtime errors after submission.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Barbearia' tenant card to open the tenant login page so a fresh login attempt can be made (index 913). Then proceed to enter credentials and submit once the login form appears.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Barbearia' tenant card to open the tenant login page so credentials can be entered and a fresh login attempt made (use interactive element index 1042).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the email and password fields and click 'ENTRAR' to attempt login (one final attempt), then wait for the dashboard to load and inspect KPI elements.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[4]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rleporesilva@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[4]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rhianlepore789')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/a408d438-b0f1-7005-16ca-13eb28705149/1769721181175007//tmp/test_task/result.webm",
    "created": "2026-01-29T21:00:49.755Z",
    "modified": "2026-01-29T21:13:01.945Z"
  },
  {
    "projectId": "507f302f-8ea7-4c0d-be20-73a44ac1fc56",
    "testId": "4f84387f-a30d-4106-ad19-2eeb44b68e3a",
    "userId": "a408d438-b0f1-7005-16ca-13eb28705149",
    "title": "TC016-Reports generation correctness for financial insights",
    "description": "Verify reports page generates accurate financial reports, including daily/monthly histories and goal tracking.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Directly navigate to http://localhost:3000/login to try a different route/hash to trigger the app router/mount since no clickable navigation elements are present.\n        await page.goto(\"http://localhost:3000/login\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Barbearia' business card (button index 364) to select the business and proceed toward the login/sign-in flow.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the email and password fields with the owner credentials and click the ENTRAR button to log in.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[4]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rleporesilva@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[4]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rhianlepore789')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Re-open the business login panel by clicking the 'Barbearia' card (button index 477) so the login form is visible again, then attempt the login flow.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the email and password fields with owner credentials and click the ENTRAR button to attempt login.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[4]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rleporesilva@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[4]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rhianlepore789')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Reload /login (or navigate to root) and run a fresh DOM diagnostic/evaluation to find visible interactive elements (inputs/buttons/business cards) so a different login approach can be attempted.\n        await page.goto(\"http://localhost:3000/login\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Reload / navigate to the homepage to re-trigger the app mount and then re-run a DOM diagnostic to locate the login form or business card.\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the business card 'Barbearia' to reveal the login panel (fresh DOM) so owner credentials can be entered and submitted.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the Email and Senha fields with the owner credentials using the visible inputs and click the ENTRAR button to submit the login form.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[4]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rleporesilva@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[4]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rhianlepore789')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Barbearia' business card (index 1199) to enter the business dashboard and verify login state (look for dashboard or reports navigation).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the visible Email and Senha inputs with the owner credentials and click the ENTRAR button to submit the login form.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[4]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rleporesilva@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[4]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rhianlepore789')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the 'Barbearia' business card to reveal the login panel, wait for the UI to render, and capture a fresh list of interactive elements (inputs/buttons) so login can be submitted reliably.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Submit owner credentials (Email + Senha) and click ENTRAR, then verify dashboard or reports navigation (check for dashboard elements and auth token presence).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[4]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rleporesilva@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[4]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rhianlepore789')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the 'Barbearia' business card to get a fresh login panel/elements so credentials can be submitted reliably.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the Email and Senha fields with the owner credentials and click ENTRAR to submit the login form, then wait for the dashboard to appear.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[4]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rleporesilva@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[4]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rhianlepore789')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/a408d438-b0f1-7005-16ca-13eb28705149/1769721229910207//tmp/test_task/result.webm",
    "created": "2026-01-29T21:00:49.761Z",
    "modified": "2026-01-29T21:13:50.122Z"
  },
  {
    "projectId": "507f302f-8ea7-4c0d-be20-73a44ac1fc56",
    "testId": "082a24af-8b9b-4055-bc4c-c6aa301148dd",
    "userId": "a408d438-b0f1-7005-16ca-13eb28705149",
    "title": "TC017-Theme switching functionality",
    "description": "Verify that the user interface applies either 'Barber' or 'Beauty' themes consistently and that automatic or manual switching works properly.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        ```\n        try:\n            await expect(frame.locator('text=Barber Theme Applied').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Expected the UI to display 'Barber Theme Applied' indicating the Barber theme was applied (via automatic establishment preference or manual switch) and theme assets updated, but the indicator did not appear so theme switching or asset application failed\")\n        ```\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Cannot complete theme verification because the single-page app did not render. Diagnostics summary:\n- Page URL: http://localhost:3000\n- Visible page: empty #root (rootInnerHTML = \"\", rootChildCount = 0). No interactive elements detected.\n- index.tsx was fetched (HTTP 200) but the module script did not execute in the page (script textLength for index.tsx is 0 in scripts list). @vite/client also appears in scripts but is not connected/executed.\n- Performance/resource list shows many app module resources with transferSize = 0 / encodedBodySize = 0, indicating assets were not actually loaded into the browser.\n- windowError / consoleErrors: null. No runtime error captured on window, but React is not mounted despite a react devtools hook being present.\n- Result: Login and navigation to settings could not be performed; theme automatic/manual switching checks cannot be executed.\nRecommended remediation steps before retrying automated verification:\n1) Ensure the dev server (Vite) is running and serving module assets. Restart the dev server (e.g., npm run dev) if necessary.\n2) Confirm the browser can load /@vite/client and all /node_modules/.vite/deps/* resources (check network tab for 200 responses and non-zero sizes).\n3) Open browser devtools console and network tab to capture runtime errors or blocked requests (CSP, CORS, or local firewall issues).\n4) If using a built production bundle, ensure the built files are present and served (or run the correct start script).\n5) After the app mounts and interactive elements appear, retry these steps: a) log in with provided credentials, b) navigate to Settings > Brand Identity / Theme, c) enable automatic theme switching and verify, d) manually toggle Barber/Beauty and verify visual changes across pages.\nIf assistance is desired after the app is rendering, retry the automated checks. Current task result: success = false (could not verify themes because app did not render).",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/a408d438-b0f1-7005-16ca-13eb28705149/1769720657014843//tmp/test_task/result.webm",
    "created": "2026-01-29T21:00:49.767Z",
    "modified": "2026-01-29T21:04:17.132Z"
  },
  {
    "projectId": "507f302f-8ea7-4c0d-be20-73a44ac1fc56",
    "testId": "204bfb86-9ff1-40fb-b236-bbdd852721f9",
    "userId": "a408d438-b0f1-7005-16ca-13eb28705149",
    "title": "TC018-Mobile responsiveness and PWA offline support",
    "description": "Verify that the UI performs well on various mobile devices and that the PWA supports offline usage with appropriate UI feedback.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Barbearia' card (interactive element index 164) to navigate into that flow so layout and PWA/offline tests can be run on subsequent screens.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Barbearia' card (interactive element index 204) to navigate into that flow so layout and PWA/offline tests can be run on subsequent screens.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the login form with provided credentials and submit to open the Barbearia dashboard so responsive and offline/PWA checks can be performed.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[4]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rleporesilva@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[4]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rhianlepore789')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Barbearia' card (interactive element index 399) to navigate into that flow and reach the login screen so responsive and offline checks can be performed.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Barbearia' card to open the Barbearia login flow so responsive and offline checks can be run on the login/dashboard screens.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Barbearia' card (index 721) to open the Barbearia login flow so responsive layout and offline/PWA diagnostics can be run on the next screen.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=You are offline - viewing cached content').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Verify that the PWA supports offline usage and provides clear UI feedback that cached pages are accessible when offline (expected message: 'You are offline - viewing cached content'). The expected offline indicator did not appear, indicating caching or offline UI feedback is not working as intended.\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Final report — verification of mobile responsiveness and PWA/offline behavior (SUMMARY)\n\nWhat was requested:\n- Verify UI performs well on various mobile devices (three viewport sizes).\n- Verify PWA supports offline usage and provides appropriate UI feedback.\n\nWhat was actually performed and observed:\n1) Initial loading behavior\n- First navigation returned an apparently blank page (document body text length 0). After repeated probes the SPA content later appeared intermittently.\n\n2) Diagnostics (JS/network/manifest/service worker)\n- The site exposes a manifest URL (/manifest.webmanifest) but fetching it returned HTML (\"<!DOCTYPE ...\") instead of valid JSON; manifest appears mis-served.\n- navigator.onLine === true in probes.\n- Service worker support available in the browser, but no service worker registrations were found (SW regs: 0).\n- No caches were enumerated (cacheNames: []).\n- Scripts (including /index.tsx and dev-client) were present on the server (diagnostics fetched them), indicating the dev server serves assets, but runtime rendering was intermittent.\n\n3) Visible UI at time of final screenshot\n- The SPA displayed two primary interactive cards: \"Barbearia\" (left) and \"Beauty & Spa\" (right). Current interactive element indexes on the page: [863] Barbearia, [940] Beauty & Spa. Several Stripe-related iframes present.\n\n4) Navigation & login attempts\n- Multiple attempts to open the Barbearia flow were made. Several click attempts failed due to elements being stale or not interactable. One click to Barbearia (index 204 earlier) succeeded briefly and showed a login form.\n- Login fields were populated once with provided credentials (email: rleporesilva@gmail.com, password: rhianlepore789). The login submit button click failed (element not interactable / stale). As a result, authentication and access to the dashboard were not achieved.\n\n5) Responsive/mobile viewport checks\n- Planned checks for small, medium, and large mobile viewports were not executed due to inability to reliably navigate into the flows and complete login.\n- Therefore no assertions about layout adjustments, clipping, or layout breaks on mobile sizes could be completed.\n\n6) Offline/PWA behavior checks\n- Offline simulation was not executed. No cached pages or offline UI behavior were verified because no service worker/caches were present and navigation to pages requiring offline checks was never completed.\n\nReasons the task could not be completed\n- Intermittent SPA rendering (initial blank document body, later content) suggests a runtime/build problem or dev-server race condition.\n- Manifest endpoint misconfigured (serves HTML, not JSON) — PWA manifest not usable.\n- No service worker registered and no caches found — offline behavior cannot be tested or expected.\n- Multiple click interactions became stale or elements were not interactable, preventing reaching and submitting the login flow reliably.\n- Because login could not be completed, downstream pages (dashboard) and their responsive/offline behavior could not be tested.\n\nConcrete findings and artifacts\n- Manifest fetch returned HTML (invalid manifest) — must fix server routing/content-type for /manifest.webmanifest.\n- Service worker registrations: none — confirm SW registration code runs at runtime and that it’s included in the served bundle.\n- Cache entries: none — without SW and caching, offline pages are not available.\n- Visible UI elements (final screenshot): two main cards present; interactive element indexes in current session: [863] Barbearia, [940] Beauty & Spa.\n- Login attempt: credentials were entered but submit could not be completed due to a non-interactable submit button.\n\nRecommended next steps to complete the requested verification (priority order)\n1) Fix manifest: ensure /manifest.webmanifest is served as valid JSON with correct Content-Type and content.\n2) Ensure the service worker registration code runs (and in dev environment either use a proper dev SW or test on a production build) so SW regs and caches appear.\n3) Investigate runtime JS errors or build race conditions causing initial blank render; check browser console and server logs; ensure the app root (#root) gets content reliably.\n4) Re-run automated checks after SW/manifest fixes: re-attempt navigation into Barbearia, complete login, and then perform the 3 mobile viewport responsiveness tests and 1 offline simulation test (simulate offline and verify cached pages and user-facing offline feedback).\n5) Ensure interactive elements are stable (use visible checks / wait for element to be enabled before clicking) to avoid stale element errors.\n\nConclusion\n- The requested verification (mobile responsiveness across 3 sizes and PWA offline tests) could not be completed due to intermittent SPA rendering, manifest misconfiguration, missing service worker/caches, and repeated interaction failures preventing login and navigation to testable pages.\n- Remaining tests: 3 mobile viewport checks and 1 offline/PWA simulation. None completed.\n\nIf further runs are desired, fix the manifest and SW registration first, then retry navigation to Barbearia, complete login, and run the viewport and offline checks. Provide console logs or server output if available to help diagnose runtime errors.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/a408d438-b0f1-7005-16ca-13eb28705149/1769720997646747//tmp/test_task/result.webm",
    "created": "2026-01-29T21:00:49.773Z",
    "modified": "2026-01-29T21:09:57.806Z"
  },
  {
    "projectId": "507f302f-8ea7-4c0d-be20-73a44ac1fc56",
    "testId": "2fa9885f-07a1-48b2-9a99-963287e52e69",
    "userId": "a408d438-b0f1-7005-16ca-13eb28705149",
    "title": "TC019-Row Level Security in multi-tenant data access",
    "description": "Verify that data is properly isolated per establishment, and users cannot access or modify other tenants' data.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate directly to the login page at /login to locate a login form or additional endpoints.\n        await page.goto(\"http://localhost:3000/login\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Select the user's establishment by clicking the appropriate establishment card (start with the 'Barbearia' card) to continue into the app and reach the login UI or authentication flow.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the email and password fields with provided credentials and click the ENTRAR button to log in to the selected establishment.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[4]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rleporesilva@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[4]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rhianlepore789')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the profile menu to look for establishment switch options and locate any session token or establishment identifier (to use for API checks).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/header/div/div[3]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the Settings (Ajustes) page to locate establishment-switch options or tenant identifiers in the UI so a cross-establishment access attempt can be performed.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/aside/nav/a[8]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open Settings (Ajustes) to locate establishment-switch options or tenant identifiers in the UI so a cross-establishment access attempt can be made.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/aside/nav/a[8]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/a408d438-b0f1-7005-16ca-13eb28705149/1769721238940013//tmp/test_task/result.webm",
    "created": "2026-01-29T21:00:49.779Z",
    "modified": "2026-01-29T21:13:59.097Z"
  },
  {
    "projectId": "507f302f-8ea7-4c0d-be20-73a44ac1fc56",
    "testId": "2021d263-cf59-44a5-b65d-3971ddd01f42",
    "userId": "a408d438-b0f1-7005-16ca-13eb28705149",
    "title": "TC020-Route protection for administrative pages",
    "description": "Verify that only authorized users, e.g. owners or admins, can access administrative routes and pages.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the login page and attempt login as the non-admin user using provided credentials.\n        await page.goto(\"http://localhost:3000/login\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Beauty & Spa' business card (interactive element index 210) to enter the app flow and reveal the login/authentication screens.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Beauty & Spa' business card (current index 303) to enter the app flow and reveal the login/authentication screens.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Enter the non-admin credentials into the email and password fields and click 'ENTRAR' to attempt login.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[2]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rleporesilva@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[2]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rhianlepore789')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Attempt to access an admin/settings route (click 'Ajustes') while in the current session to verify whether access is permitted for this user.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/aside/nav/a[8]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the current 'Ajustes' sidebar item (index 1418) to test whether the logged-in user can access the admin/settings page and observe the result (redirect, error, or allowed).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/aside/nav/a[8]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Gather the current page content: list visible headings, sidebar items, buttons or links that indicate administrative access (Usuários, Financeiro, Administração, Donos, Permissões) and capture any visible error/notice and the current URL. Then open the profile menu to look for role or logout options.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/header/div/div[3]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the profile menu to inspect user role and logout/profile links (look for role label or admin links), then attempt to navigate to admin-only routes if available.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/header/div/div[3]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the profile menu to inspect the current user's role and any admin/logout links (click header profile button). If profile menu opens, check for role label or 'Usuários' / 'Financeiro' links and record results.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/header/div/div[3]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Attempt to access the user-management admin route as the current (non-admin) session to verify whether access is allowed or denied.\n        await page.goto(\"http://localhost:3000/login#/usuarios\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Attempt to open the Financeiro (finance) page from the sidebar to check whether the current (non-admin) session can access finance management.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/aside/nav/a[5]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the Financeiro sidebar item (current index 6789) to verify whether the logged-in non-admin can access finance/admin area.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/aside/nav/a[5]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the profile menu to confirm the current user's role and visible admin links, then extract the visible menu items/labels (role, logout, admin links). This will determine whether the current account has admin privileges and then decide next steps (attempt to open Usuários via UI).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/header/div/div[3]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/a408d438-b0f1-7005-16ca-13eb28705149/1769721294900801//tmp/test_task/result.webm",
    "created": "2026-01-29T21:00:49.786Z",
    "modified": "2026-01-29T21:14:55.149Z"
  },
  {
    "projectId": "507f302f-8ea7-4c0d-be20-73a44ac1fc56",
    "testId": "863170db-0d46-4403-9a3c-19593dac602e",
    "userId": "a408d438-b0f1-7005-16ca-13eb28705149",
    "title": "TC021-Team and services management CRUD operations",
    "description": "Verify that owners or admins can create, update, and delete professional team members and service offerings reliably.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Fetch and inspect /App.tsx to find runtime errors or missing imports that prevented the SPA from mounting. Then fetch any missing dependency files referenced by App (if necessary).\n        await page.goto(\"http://localhost:3000/App.tsx\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Fetch and inspect the authentication context implementation (/contexts/AuthContext.tsx) to determine why isAuthenticated/loading state may be blocking the app from mounting and to identify any runtime errors or missing dependencies.\n        await page.goto(\"http://localhost:3000/contexts/AuthContext.tsx\", wait_until=\"commit\", timeout=10000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Team member added successfully').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: expected 'Team member added successfully' confirmation after adding a new professional member, but the confirmation did not appear — the member may not have been created or the UI failed to update\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test cannot proceed because the web app front-end did not initialize in the browser. Diagnostic summary:\n- document.readyState = 'complete'\n- Page title = 'Beauty OS'\n- <div id=\"root\"></div> present but empty (no mounted children)\n- /index.tsx served (HTTP 200) and imports /App.tsx\n- /contexts/AuthContext.tsx contains Vite/react-refresh HMR preamble that throws when window.$RefreshReg$ is undefined; environment check shows window.$RefreshReg$ = false, hasViteClient = false, hasRefreshSig = false\n- Result: module initialization aborted due to missing react-refresh preamble, leaving SPA unmounted and no interactive UI for login or CRUD tests\nRequired next steps (options):\n1) Confirm /@vite/client is being served and included before app modules (check server and network for /@vite/client). 2) Restart dev server so Vite client and react-refresh preamble are available, or serve a production build (recommended for stable tests). 3) After SPA is successfully mounted and interactive elements appear, rerun the test plan: login with provided credentials, navigate to team & services, create/edit/delete professional members and services, and verify UI updates.\nBecause the runtime error prevents performing any UI interactions, the verification task cannot be completed now. Provide server/dev environment fixes and then re-run the UI test steps.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/a408d438-b0f1-7005-16ca-13eb28705149/1769720695451376//tmp/test_task/result.webm",
    "created": "2026-01-29T21:00:49.792Z",
    "modified": "2026-01-29T21:04:55.569Z"
  },
  {
    "projectId": "507f302f-8ea7-4c0d-be20-73a44ac1fc56",
    "testId": "1e5a2f09-6eeb-4a90-8145-94fc031b94a8",
    "userId": "a408d438-b0f1-7005-16ca-13eb28705149",
    "title": "TC022-Onboarding wizard complete business setup",
    "description": "Verify that the onboarding wizard guides users step-by-step to setup new business including profile, team, services, and operating hours, and finalizes with successful launch.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Reload the app (navigate to the same URL) to force the SPA to initialize, then inspect the DOM for onboarding entry points like 'Get started', 'Start onboarding', or login fields.\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the app's client module (/index.tsx) to inspect the script source and check for runtime errors or missing resources so the SPA can be repaired or loaded.\n        await page.goto(\"http://localhost:3000/index.tsx\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open /App.tsx to inspect the App component for onboarding wizard entry point and check why the SPA did not mount or render.\n        await page.goto(\"http://localhost:3000/App.tsx\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the OnboardingWizard component source (/pages/OnboardingWizard.tsx) to inspect the step flow, form fields, and save/submit handlers so verification can proceed without a running SPA.\n        await page.goto(\"http://localhost:3000/pages/OnboardingWizard.tsx\", wait_until=\"commit\", timeout=10000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Business Successfully Launched!').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The onboarding wizard did not complete successfully — after completing profile, team, services, and operating hours, the expected confirmation 'Business Successfully Launched!' did not appear, indicating the configuration was not saved or the final launch step failed.\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Summary of verification and findings:\n\nWhat was checked:\n- The development server was loaded and the client modules were opened; the SPA UI did not mount in the browser (page body minimal, no interactive DOM). Diagnostic evaluate results show scripts and importmap present but React did not render into the page.\n- The OnboardingWizard component (pages/OnboardingWizard.tsx) was inspected in source form.\n\nWhat the source shows (code-level verification):\n- The onboarding flow is implemented as a 5-step wizard. Steps array (in order):\n  1) StepBusinessInfo (title: Bem-vindo ao Beauty OS / Barber OS) — onNext sets step=2\n  2) StepBusinessHours — onNext sets step=3, onBack sets step=1\n  3) StepTeam — onNext sets step=4, onBack sets step=2\n  4) StepServices — onNext sets step=5, onBack sets step=3\n  5) StepSuccess — final success screen\n- Navigation between steps is implemented by setStep and onNext/onBack handlers passed into each step component. The wizard is wrapped in OnboardingLayout and receives currentStep and totalSteps.\n- Progress/resume logic: checkProgress() reads supabase.from('business_settings').select('onboarding_step, onboarding_completed').eq('user_id', user.id).single();\n  - If onboarding_completed is true -> navigate('/') (redirects away)\n  - If onboarding_step exists -> setStep(data.onboarding_step)\n  - Loading state shown while checkProgress runs\n- Authentication & user type: useAuth() is used to gate behavior and to compute accent color (beauty vs barber). The wizard depends on a logged-in user and on supabase data for resuming/completion.\n- Persistence: OnboardingWizard delegates per-step behavior to the Step* components. Those components are responsible for collecting input and saving to supabase (not yet inspected here). Therefore persistence and finalization logic likely lives in StepBusinessInfo.tsx, StepBusinessHours.tsx, StepTeam.tsx, StepServices.tsx, and StepSuccess.tsx.\n\nWhat could not be verified interactively:\n- Cannot start the wizard in the running UI, cannot fill forms, cannot complete wizard steps in the browser, and cannot assert data persistence or redirect behavior because the React app did not mount.\n\nObserved runtime/blocker details (evidence):\n- Page body is very small (bodyLength ~116) and there are no interactive elements reported by the browser state.\n- The client module output contains HMR/react-refresh code that can throw: \"@vitejs/plugin-react can't detect preamble. Something is wrong.\" This indicates a possible runtime or HMR preamble mismatch and may be the reason the SPA failed to mount.\n\nConclusion:\n- Code-level verification: The onboarding wizard component defines and composes the exact step-by-step flow requested (business profile, hours, team, services, success) and includes resume/redirect checks via supabase business_settings. The structure and navigation between steps are implemented in source.\n- Integration-level verification: Not completed. Interactive verification (starting the wizard, filling each step, completing the wizard, and confirming persistence and a successful launch) could not be executed because the SPA did not render in the browser. Therefore it is not possible to assert that the actual UI saves configuration or that the business profile is functional at run-time.\n\nRecommended next steps to enable full verification (ordered):\n1) Fix the SPA runtime so the React app mounts:\n   - Check the browser console and server terminal for runtime errors from Vite or react-refresh.\n   - Ensure index.html contains the root mount node (e.g., <div id=\"root\"></div>) and that index.tsx mounts to it.\n   - Address any thrown error about \"@vitejs/plugin-react can't detect preamble\" (may indicate a build/HMR misconfiguration or missing preamble injected by the plugin).\n2) Once the app mounts, perform the interactive test using the provided test credentials (or create a test account):\n   - Log in (use provided credentials if desired).\n   - Start onboarding (should render StepBusinessInfo first).\n   - Fill and submit each step in order (Business info -> Hours -> Team -> Services), using realistic test values.\n   - At each step verify the step saves state to the backend (check supabase row business_settings for onboarding_step or step-specific tables/rows). Verify that after finalizing onboarding, onboarding_completed is set true and the app redirects to the dashboard (/).\n   - Confirm business profile data appears in the app and that booking/configuration pages reflect entered data.\n3) Inspect these step components' sources (StepBusinessInfo.tsx, StepBusinessHours.tsx, StepTeam.tsx, StepServices.tsx, StepSuccess.tsx) to confirm exact persistence calls and validation logic before or during interactive testing.\n\nFinal status:\n- The onboarding wizard structure is present and implements the requested step-by-step flow in source code.\n- Interactive end-to-end verification could not be performed due to SPA not mounting in the browser. Interactive verification and final success validation remain blocked until runtime issues are resolved.\n\nIf desired, next actions can be:\n- Provide console/server logs to diagnose the runtime error, or\n- Allow inspection of the Step* components' source files now so persistence logic can be statically reviewed, or\n- Attempt to reload/repair the app runtime in the environment and re-run the interactive test.\n",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/a408d438-b0f1-7005-16ca-13eb28705149/1769720745294905//tmp/test_task/result.webm",
    "created": "2026-01-29T21:00:49.798Z",
    "modified": "2026-01-29T21:05:45.442Z"
  },
  {
    "projectId": "507f302f-8ea7-4c0d-be20-73a44ac1fc56",
    "testId": "211482bb-a3c7-485e-9cd1-582930bb99e4",
    "userId": "a408d438-b0f1-7005-16ca-13eb28705149",
    "title": "TC023-Client CRM data accuracy and search functionality",
    "description": "Verify that client data is saved correctly and can be searched and filtered accurately.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Reload the page to attempt to initialize the SPA, then re-inspect the page for login inputs or other interactive elements.\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Reload the page to attempt to initialize the SPA, then re-inspect the page for login inputs and interactive elements\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Enter the 'Beauty & Spa' workspace by clicking the corresponding selection card/button (index 229) to proceed to the login/workspace screen.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Beauty & Spa' selection card (index 364) to enter that workspace and continue to the login screen.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill email and password into the login form and submit the 'ENTRAR' button to log in as staff/owner.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[2]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rleporesilva@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[2]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rhianlepore789')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Beauty & Spa' workspace card (index 566) to enter the workspace and proceed to the login screen.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the email and password into the login inputs (indices 619 and 625) and click the ENTRAR button (index 640) to log in.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[2]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rleporesilva@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/div[2]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rhianlepore789')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Enter the 'Beauty & Spa' workspace and open the login screen by clicking the corresponding workspace card (button index 747), so the login form can be filled and submitted.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Beauty & Spa' workspace card to enter the workspace (use button index 875).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Beauty & Spa' workspace card (index 1008) to open the login screen so login can be performed.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Client Successfully Added!').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The test attempted to verify that a newly added client was saved and visible/searchable in the client list (confirmation text 'Client Successfully Added!' or the client entry should appear), but the expected confirmation/list entry did not appear — the client may not have been saved or the search/filter did not return the record.\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Final report of automation attempt (task: verify client data saved, searchable, filterable, and persists):\n\nWhat was attempted:\n- Opened http://localhost:3000 and waited for SPA to initialize (multiple reloads/waits/inspections).\n- Located workspace selection UI (two cards: 'Barbearia' and 'Beauty & Spa').\n- Entered the 'Beauty & Spa' workspace several times; the login form rendered on at least two occasions.\n- Filled login form with provided credentials twice:\n  - email: rleporesilva@gmail.com\n  - password: rhianlepore789\n- Attempted to submit the login form (button labeled ENTRAR) twice; both attempts failed with \"element not interactable / stale\" errors.\n- After failed submit attempts the app frequently returned to the workspace selection screen; no authenticated session was reached.\n- No CRM actions (add client, verify list, search, update, verify persistence) were performed because login never completed.\n\nObserved failures and diagnostics:\n- Primary blocking error: Login submit clicks failed repeatedly with \"element not interactable / stale\". Element indexes changed between attempts, causing stale references.\n- App behavior: SPA shell and scripts loaded, but client UI intermittently failed to remain in the login state and reverted to workspace selection. Body content lengths and interactive element counts fluctuated across attempts.\n- Last visible interactive elements: 2 workspace selection buttons. No persistent logged-in UI available for further CRM operations.\n\nCounts/status (for repeatable tasks):\n- Navigations: 3\n- Waits: 2\n- DOM evaluations: 2\n- Workspace click attempts: multiple (>=4)\n- Email/password typed: 2 each\n- Submit attempts: 2 (both failed)\n- CRM test steps completed: 0 of 6\n\nPossible next steps and recommendations to proceed (manual/dev actions):\n1. Check the browser console and server logs for client-side JavaScript errors that prevent the SPA from initializing or cause the UI to revert.\n2. Ensure the backend/API and dev server (http://localhost:3000) are running and reachable from the test environment.\n3. Investigate why the ENTRAR button is not interactable: it may be covered by an overlay, not enabled, or the DOM is re-rendering leading to stale element references.\n4. Try interacting with the form via keyboard (press Enter) or re-query the button right before clicking to avoid stale references.\n5. Add waits for animations or re-renders prior to clicking, or use stable selectors that are queried immediately before interaction.\n6. Retry the automated sequence after fixes: login, add client with full details, verify client appears, search by attributes, update client, and confirm persistence.\n\nConclusion:\n- The automation did not complete the requested verification. Login and all CRM steps remain undone due to repeated interactability/stale element failures. Further debugging and environment fixes are required before the automation can finish reliably.\n\nIf desired, provide console logs and network traces from the environment and a rerun after fixes can be attempted.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/a408d438-b0f1-7005-16ca-13eb28705149/1769720960755161//tmp/test_task/result.webm",
    "created": "2026-01-29T21:00:49.805Z",
    "modified": "2026-01-29T21:09:20.944Z"
  }
]
