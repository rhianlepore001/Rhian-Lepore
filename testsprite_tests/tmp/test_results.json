[
  {
    "projectId": "a012f828-a974-4c5f-b691-e13c1f407366",
    "testId": "047e7797-7486-44c4-8187-762797b32ef4",
    "userId": "54d844a8-4011-70b7-cc9a-127a66d438d2",
    "title": "TC001-Successful registration redirects to onboarding",
    "description": "Verifies a new user can register with valid details and is redirected into the onboarding wizard.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate to /register (http://localhost:3000/register) to load the registration page and then verify the page title contains 'Register'.\n        await page.goto(\"http://localhost:3000/register\", wait_until=\"commit\", timeout=10000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Register').first).to_be_visible(timeout=3000)\n        assert '/onboarding' in frame.url\n        await expect(frame.locator('text=Onboarding').first).to_be_visible(timeout=3000)\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "TEST FAILURE\n\nASSERTIONS:\n- Registration page at /register did not render: 0 interactive elements found on the page.\n- Page title does not contain 'Register' and the registration form inputs (business name, email, password) are not present.\n- Unable to enter credentials or click the Register button because no input fields or buttons were available.\n- Cannot verify onboarding redirect or presence of 'Onboarding' text because the registration form could not be submitted.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/54d844a8-4011-70b7-cc9a-127a66d438d2/177229743519268//tmp/test_task/result.webm",
    "created": "2026-02-28T16:49:06.293Z",
    "modified": "2026-02-28T16:50:35.305Z"
  },
  {
    "projectId": "a012f828-a974-4c5f-b691-e13c1f407366",
    "testId": "7a836bd7-2dbf-404c-90e3-1f6585b84783",
    "userId": "54d844a8-4011-70b7-cc9a-127a66d438d2",
    "title": "TC002-Registration with already-registered email shows error",
    "description": "Verifies the system blocks registration when the email is already in use and displays an appropriate error message.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate to /register (http://localhost:3000/register) using the required navigate action so the registration page can be tested.\n        await page.goto(\"http://localhost:3000/register\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Barbearia' business card to reveal the registration form (element index 268).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Não tem conta? Criar agora' link (interactive element index 326) to open the registration flow.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div/div/div[2]/div[2]/div[5]/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Type 'Test Barber Shop' into the business name input (index 556) and then fill email and passwords, then click the Finalizar Cadastro submit button (index 576).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div[2]/form/div[6]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test Barber Shop')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div[2]/form/div[6]/div[2]/div[3]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('existing.user@example.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div[1]/div/div[2]/form/div[6]/div[2]/div[4]/div[1]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('ValidPass!234')\n        \n        # -> Click the 'Finalizar Cadastro' submit button (index 1030) to attempt registration and trigger the duplicate-email validation message.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div/div/div[2]/form/div[7]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the missing required fields (Seu Nome index 980 and Nome do Negócio index 985), ensure Email (index 1001) is set to existing.user@example.com and Password/Confirm (indices 1006 and 1014) set to ValidPass!234, then click the Finalizar Cadastro submit button (index 1030) to trigger server-side duplicate-email validation and observe any error messages.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div[2]/form/div[6]/div/div[3]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test Owner')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div[2]/form/div[6]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test Barber Shop')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div[2]/form/div[6]/div[2]/div[3]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('existing.user@example.com')\n        \n        # -> Fill required registration fields on the visible form (Seu Nome, Nome do Negócio, Email, Senha, Confirmar) and click the Finalizar Cadastro (index=1129) to trigger duplicate-email validation, then check for error messages.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div[2]/form/div[6]/div/div[3]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test Owner')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div[2]/form/div[6]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test Barber Shop')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div[2]/form/div[6]/div[2]/div[3]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('existing.user@example.com')\n        \n        # -> Fill required registration fields (Seu Nome, Nome do Negócio, Email, Senha, Confirmar) and click the Finalizar Cadastro submit button (index 1398) to trigger duplicate-email validation and then check for the expected error messages and URL.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div[2]/form/div[6]/div/div[3]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test Owner')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div[2]/form/div[6]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test Barber Shop')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div[2]/form/div[6]/div[2]/div[3]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('existing.user@example.com')\n        \n        # -> Fill the password and confirm fields with 'ValidPass!234' and click the Finalizar Cadastro submit button (index 1398) to trigger duplicate-email validation.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div[2]/form/div[6]/div[2]/div[4]/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('ValidPass!234')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div[2]/form/div[6]/div[2]/div[4]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('ValidPass!234')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div/div/div[2]/form/div[7]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the required registration fields on the visible form and click Finalizar Cadastro (submit) to trigger server-side duplicate-email validation, then check for the expected error message.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div[2]/form/div[6]/div/div[3]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test Owner')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div[2]/form/div[6]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test Barber Shop')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div[2]/form/div[6]/div[2]/div[3]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('existing.user@example.com')\n        \n        # -> Fill required fields (Seu Nome, Nome do Negócio, Email, Senha, Confirmar) on the visible registration form and click the Finalizar Cadastro (index 2157) to trigger server-side duplicate-email validation and observe error messages.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div[2]/form/div[6]/div/div[3]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test Owner')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div[2]/form/div[6]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test Barber Shop')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div[2]/form/div[6]/div[2]/div[3]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('existing.user@example.com')\n        \n        # -> Fill the registration fields (Seu Nome, Nome do Negócio, Email, Senha, Confirmar) on the visible form and click Finalizar Cadastro (index=2250) to trigger server-side duplicate-email validation and observe the error message.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div[2]/form/div[6]/div/div[3]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test Owner')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div[2]/form/div[6]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test Barber Shop')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div[2]/form/div[6]/div[2]/div[3]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('existing.user@example.com')\n        \n        # -> Fill both password fields with 'ValidPass!234' and click the 'Finalizar Cadastro' submit button to trigger server-side duplicate-email validation and observe any error messages or page changes.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div[2]/form/div[6]/div[2]/div[4]/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('ValidPass!234')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div[2]/form/div[6]/div[2]/div[4]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('ValidPass!234')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div/div/div[2]/form/div[7]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the required registration fields (Seu Nome, Nome do Negócio, Email, Senha, Confirmar) on the visible form and click Finalizar Cadastro to trigger server-side duplicate-email validation and observe any error messages (then verify error text and URL in the next step).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div[2]/form/div[6]/div/div[3]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test Owner')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div[2]/form/div[6]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test Barber Shop')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div[2]/form/div[6]/div[2]/div[3]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('existing.user@example.com')\n        \n        # -> Fill both password fields with 'ValidPass!234' and click the Finalizar Cadastro submit button (index 2543) to trigger duplicate-email validation and observe any error messages.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div[2]/form/div[6]/div[2]/div[4]/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('ValidPass!234')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div[2]/form/div[6]/div[2]/div[4]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('ValidPass!234')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div/div/div[2]/form/div[7]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill all required registration fields on the visible form and submit to trigger server-side duplicate-email validation, then check for the expected error message and URL.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div[2]/form/div[6]/div/div[3]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test Owner')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div[2]/form/div[6]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test Barber Shop')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div[2]/form/div[6]/div[2]/div[3]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('existing.user@example.com')\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        frame = context.pages[-1]\n        # Verify current URL contains /register\n        assert \"/register\" in frame.url\n        # Ensure the email input is present (page loaded)\n        email_input = frame.locator('xpath=/html/body/div[1]/div/div[2]/form/div[6]/div[2]/div[3]/input').nth(0)\n        await email_input.wait_for(state='visible', timeout=5000)\n        # Check for expected duplicate-email error text fragments 'already' and 'account' in page content\n        content = await frame.content()\n        missing = []\n        if 'already' not in content: missing.append('\"already\"')\n        if 'account' not in content: missing.append('\"account\"')\n        if missing:\n            raise AssertionError(f\"Expected text(s) {', '.join(missing)} not found on page. Duplicate-email error message not present or uses different wording; feature may not exist.\")\n        # Both fragments present -> test passed\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/54d844a8-4011-70b7-cc9a-127a66d438d2/1772298137635561//tmp/test_task/result.webm",
    "created": "2026-02-28T16:49:06.298Z",
    "modified": "2026-02-28T17:02:17.774Z"
  },
  {
    "projectId": "a012f828-a974-4c5f-b691-e13c1f407366",
    "testId": "0bc07f0e-bda6-4076-8ff3-3fea08b27aea",
    "userId": "54d844a8-4011-70b7-cc9a-127a66d438d2",
    "title": "TC009-Request password reset with a registered email shows confirmation message",
    "description": "Verifies a user can submit the forgot password form and sees a confirmation to check email.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate to /forgot-password (use explicit navigate to http://localhost:3000/forgot-password as the test step requests).\n        await page.goto(\"http://localhost:3000/forgot-password\", wait_until=\"commit\", timeout=10000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Forgot').first).to_be_visible(timeout=3000)\n        await expect(frame.locator('text=check your email').first).to_be_visible(timeout=3000)\n        await expect(frame.locator('text=reset link').first).to_be_visible(timeout=3000)\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "TEST FAILURE\n\nASSERTIONS:\n- Forgot-password page did not render any interactive elements; page appears blank.\n- Email input field not found on page (no input elements available).\n- 'Send reset link' button not found on page (no buttons available).\n- Confirmation text 'check your email' is not visible on the page.\n- Confirmation text 'reset link' is not visible on the page.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/54d844a8-4011-70b7-cc9a-127a66d438d2/1772297433800918//tmp/test_task/result.webm",
    "created": "2026-02-28T16:49:06.304Z",
    "modified": "2026-02-28T16:50:33.938Z"
  },
  {
    "projectId": "a012f828-a974-4c5f-b691-e13c1f407366",
    "testId": "fab794f8-996e-4c3a-abf6-61b88d3696f9",
    "userId": "54d844a8-4011-70b7-cc9a-127a66d438d2",
    "title": "TC010-Request password reset with an unregistered email shows 'email not found' error",
    "description": "Verifies submitting an unknown email displays an appropriate error message.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate to /forgot-password (http://localhost:3000/forgot-password) to access the forgot-password form and continue the test.\n        await page.goto(\"http://localhost:3000/forgot-password\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Beauty & Spa' card (button index 225) to navigate into the app flow that should expose the login/forgot-password form.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div/div/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Esqueci minha senha' link (index 278) to open the forgot-password form.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div/div[2]/div[2]/div[3]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Beauty & Spa' business card (index 439) to enter the login flow so the 'Esqueci minha senha' link and forgot-password form can be reached.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div/div/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Beauty & Spa' business card (index 638) to enter the login flow so the 'Esqueci minha senha' link and forgot-password form become available.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div/div/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Beauty & Spa' business card (button index 850) to enter the login flow so the 'Esqueci minha senha' link and forgot-password form can be reached.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div/div/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=email not found').first).to_be_visible(timeout=3000)\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "TEST FAILURE\n\nASSERTIONS:\n- Forgot-password page did not contain any interactive elements; page shows 0 interactive elements.\n- 'Esqueci minha senha' link clicks failed or were not interactable/stale on multiple attempts, preventing opening the forgot-password form.\n- The UI repeatedly returned to the business-selection view, preventing access to login/forgot-password inputs.\n- Unable to enter an email or click the 'Send reset link' button because the forgot-password form could not be reached.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/54d844a8-4011-70b7-cc9a-127a66d438d2/1772297695824707//tmp/test_task/result.webm",
    "created": "2026-02-28T16:49:06.309Z",
    "modified": "2026-02-28T16:54:55.988Z"
  },
  {
    "projectId": "a012f828-a974-4c5f-b691-e13c1f407366",
    "testId": "68a822c2-a7e5-440d-970e-cd317efd7bab",
    "userId": "54d844a8-4011-70b7-cc9a-127a66d438d2",
    "title": "TC016-Successful password update redirects user to Login",
    "description": "Verifies a user can set a new password and is redirected to the login page with a visible confirmation.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate to /update-password (use explicit navigate to http://localhost:3000/update-password).\n        await page.goto(\"http://localhost:3000/update-password\", wait_until=\"commit\", timeout=10000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Update').first).to_be_visible(timeout=3000)\n        await expect(frame.locator('text=Password updated').first).to_be_visible(timeout=3000)\n        assert '/login' in frame.url\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "TEST FAILURE\n\nASSERTIONS:\n- ASSERTION: The /update-password page loaded but contains 0 interactive elements, indicating the application did not render the update-password form.\n- ASSERTION: New password input field not found on the page.\n- ASSERTION: Confirm password input field not found on the page.\n- ASSERTION: 'Update Password' button not found on the page.\n- ASSERTION: Unable to verify 'Password updated' message or redirection to '/login' because the page did not render.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/54d844a8-4011-70b7-cc9a-127a66d438d2/1772297456355598//tmp/test_task/result.webm",
    "created": "2026-02-28T16:49:06.315Z",
    "modified": "2026-02-28T16:50:56.475Z"
  },
  {
    "projectId": "a012f828-a974-4c5f-b691-e13c1f407366",
    "testId": "c25eb306-122a-48d4-aa56-da127264da71",
    "userId": "54d844a8-4011-70b7-cc9a-127a66d438d2",
    "title": "TC017-Mismatched passwords show validation error",
    "description": "Verifies the form blocks submission when the confirmation password does not match and shows the correct error message.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate to /update-password using the required explicit navigate action to http://localhost:3000/update-password (per test instruction).\n        await page.goto(\"http://localhost:3000/update-password\", wait_until=\"commit\", timeout=10000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=passwords do not match').first).to_be_visible(timeout=3000)\n        assert '/update-password' in frame.url\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "TEST FAILURE\n\nASSERTIONS:\n- Update password form not found on /update-password: page contains 0 interactive elements and no form fields.\n- New password input field not present on the page, so password entry cannot be performed.\n- Confirm password input field not present on the page, so confirmation cannot be entered.\n- 'Update Password' button not found on the page, so form submission cannot be triggered.\n- Cannot verify error message 'passwords do not match' because the form and its controls are missing.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/54d844a8-4011-70b7-cc9a-127a66d438d2/1772297428449202//tmp/test_task/result.webm",
    "created": "2026-02-28T16:49:06.320Z",
    "modified": "2026-02-28T16:50:28.562Z"
  },
  {
    "projectId": "a012f828-a974-4c5f-b691-e13c1f407366",
    "testId": "e487fa2e-8245-4f60-a91d-46ddb19dd463",
    "userId": "54d844a8-4011-70b7-cc9a-127a66d438d2",
    "title": "TC018-Empty submission shows required field validation",
    "description": "Verifies the user cannot submit the update form with empty fields and sees required field errors.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate to /update-password by using the explicit navigate action to http://localhost:3000/update-password (per test instruction).\n        await page.goto(\"http://localhost:3000/update-password\", wait_until=\"commit\", timeout=10000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=New password is required').first).to_be_visible(timeout=3000)\n        await expect(frame.locator('text=Confirm password is required').first).to_be_visible(timeout=3000)\n        assert '/update-password' in frame.url\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "TEST FAILURE\n\nASSERTIONS:\n- ASSERTION: Update Password page at http://localhost:3000/update-password rendered with no interactive elements; form not present.\n- ASSERTION: 'Update Password' button not found on page.\n- ASSERTION: Required-field validation could not be triggered because form fields are missing.\n- ASSERTION: SPA appears not to have rendered on /update-password (page content empty).\n- ASSERTION: Unable to verify visibility of 'New password is required' and 'Confirm password are required' messages due to missing form.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/54d844a8-4011-70b7-cc9a-127a66d438d2/1772297452598874//tmp/test_task/result.webm",
    "created": "2026-02-28T16:49:06.325Z",
    "modified": "2026-02-28T16:50:52.724Z"
  },
  {
    "projectId": "a012f828-a974-4c5f-b691-e13c1f407366",
    "testId": "4ac8c74a-5897-40b8-8550-3a347d838fc4",
    "userId": "54d844a8-4011-70b7-cc9a-127a66d438d2",
    "title": "TC022-Join an open queue successfully and land on queue status page",
    "description": "Verifies a public visitor can join an open queue and is redirected to a queue status page showing their position.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate to a public queue join URL (append /queue/1 to the base URL) and check for the 'Join Queue' flow.\n        await page.goto(\"http://localhost:3000/queue/1\", wait_until=\"commit\", timeout=10000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Join Queue').first).to_be_visible(timeout=3000)\n        assert '/queue-status/' in frame.url\n        await expect(frame.locator('text=Position').first).to_be_visible(timeout=3000)\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "TEST FAILURE\n\nASSERTIONS:\n- ASSERTION: Page did not render - 0 interactive elements present on /queue/1.\n- ASSERTION: 'Join Queue' button not found on the page.\n- ASSERTION: Name and phone input fields not found on the page.\n- ASSERTION: Could not perform join flow or verify redirect to '/queue-status/' due to missing UI elements.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/54d844a8-4011-70b7-cc9a-127a66d438d2/1772297462301956//tmp/test_task/result.webm",
    "created": "2026-02-28T16:49:06.331Z",
    "modified": "2026-02-28T16:51:02.420Z"
  },
  {
    "projectId": "a012f828-a974-4c5f-b691-e13c1f407366",
    "testId": "64b59048-5f5f-40ac-8cd9-f0c0157ef4d4",
    "userId": "54d844a8-4011-70b7-cc9a-127a66d438d2",
    "title": "TC023-Queue join requires name (validation prevents confirmation)",
    "description": "Verifies the join flow blocks submission when the name field is empty.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Name').first).to_be_visible(timeout=3000)\n        assert '/queue/' in frame.url\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "TEST FAILURE\n\nASSERTIONS:\n- ASSERTION: Root page (http://localhost:3000/) loaded but contains 0 interactive elements; SPA content did not render.\n- ASSERTION: No 'Join Queue' button found on the page; the join flow cannot be started.\n- ASSERTION: Phone input and 'Confirm Join' controls are not present; form submission cannot be exercised.\n- ASSERTION: Unable to verify visibility of 'Name' field or that the URL contains '/queue/' because the queue page UI is unreachable.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/54d844a8-4011-70b7-cc9a-127a66d438d2/1772297414516429//tmp/test_task/result.webm",
    "created": "2026-02-28T16:49:06.337Z",
    "modified": "2026-02-28T16:50:14.623Z"
  },
  {
    "projectId": "a012f828-a974-4c5f-b691-e13c1f407366",
    "testId": "b6e20457-2f4f-41c7-81e6-0280547091bb",
    "userId": "54d844a8-4011-70b7-cc9a-127a66d438d2",
    "title": "TC024-Queue join requires phone (validation prevents confirmation)",
    "description": "Verifies the join flow blocks submission when the phone field is empty.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Phone').first).to_be_visible(timeout=3000)\n        assert '/queue/' in frame.url\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "TEST FAILURE\n\nASSERTIONS:\n- Root page at http://localhost:3000/ did not render application content; page contains 0 interactive elements.\n- No 'Join Queue' button or any navigation element to a '/queue/' page was present on the loaded page.\n- Join flow could not be tested because the public queue URL ('/queue/...') could not be reached or was not provided.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/54d844a8-4011-70b7-cc9a-127a66d438d2/1772297405613599//tmp/test_task/result.webm",
    "created": "2026-02-28T16:49:06.342Z",
    "modified": "2026-02-28T16:50:05.728Z"
  },
  {
    "projectId": "a012f828-a974-4c5f-b691-e13c1f407366",
    "testId": "780be8d6-5a2d-4cf3-8f8c-c453390e2349",
    "userId": "54d844a8-4011-70b7-cc9a-127a66d438d2",
    "title": "TC026-Attempt to join when queue is closed or full shows error message",
    "description": "Verifies the application shows an explicit error when attempting to join a closed/full queue.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Wait briefly for the SPA to finish loading, then try to navigate directly to a candidate public queue URL (http://localhost:3000/queue/1) because no clickable navigation element is present on the current page.\n        await page.goto(\"http://localhost:3000/queue/1\", wait_until=\"commit\", timeout=10000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=queue closed or full').first).to_be_visible(timeout=3000)\n        assert '/queue/' in frame.url\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "TEST FAILURE\n\nASSERTIONS:\n- Join Queue button not found on page (no interactive elements present)\n- Name input field not found on page\n- Phone input field not found on page\n- Confirm Join button not found on page\n- Queue page did not render - SPA content missing (0 interactive elements)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/54d844a8-4011-70b7-cc9a-127a66d438d2/1772297445401373//tmp/test_task/result.webm",
    "created": "2026-02-28T16:49:06.348Z",
    "modified": "2026-02-28T16:50:45.546Z"
  },
  {
    "projectId": "a012f828-a974-4c5f-b691-e13c1f407366",
    "testId": "127379e0-b71a-4102-ad29-76686c0bc9ca",
    "userId": "54d844a8-4011-70b7-cc9a-127a66d438d2",
    "title": "TC029-Valid queue status page shows position and estimated wait",
    "description": "Verifies that a queue status page displays the client’s current position and an estimated wait time.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate to http://localhost:3000/queue-status/ to load the queue status page, then verify the title contains 'Queue', 'Position' text is visible, 'Estimated' text is visible, 'min' text is visible, and the URL contains '/queue-status/'.\n        await page.goto(\"http://localhost:3000/queue-status/\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Barbearia' service card (element index 150) to navigate to the queue status or login page, then verify the 5 assertions on the resulting page.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the login form with provided credentials and submit (click 'ENTRAR') to authenticate and then check the queue-status page for position and estimated wait.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div[2]/div[2]/div[4]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rleporesilva@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div[2]/div[2]/div[4]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rhianlepore789')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div/div/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Fila Digital' (queue) sidebar link (interactive element index 735) to navigate to the queue view or locate a public /queue-status/ link.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div/div/aside/nav/a[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Gerar QR Code' button (index 1321) to open the QR/modal and look for a public /queue-status/ link or shareable URL that can be used to verify the client's position and estimated wait.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div/div/main/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Navigate to the public queue URL shown in the QR modal (http://localhost:3000/#/queue/vanessa-lepore) to check for the client's position and estimated wait.\n        await page.goto(\"http://localhost:3000/#/queue/vanessa-lepore\", wait_until=\"commit\", timeout=10000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Queue').first).to_be_visible(timeout=3000)\n        await expect(frame.locator('text=Position').first).to_be_visible(timeout=3000)\n        await expect(frame.locator('text=Estimated').first).to_be_visible(timeout=3000)\n        await expect(frame.locator('text=min').first).to_be_visible(timeout=3000)\n        assert '/queue-status/' in frame.url\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/54d844a8-4011-70b7-cc9a-127a66d438d2/1772297782082017//tmp/test_task/result.webm",
    "created": "2026-02-28T16:49:06.354Z",
    "modified": "2026-02-28T16:56:22.194Z"
  },
  {
    "projectId": "a012f828-a974-4c5f-b691-e13c1f407366",
    "testId": "9fd36a69-c9de-4460-8a6c-cce5f7e682c9",
    "userId": "54d844a8-4011-70b7-cc9a-127a66d438d2",
    "title": "TC031-Real-time updates refresh visible queue position when it changes",
    "description": "Verifies the page receives real-time updates by observing a change in the visible position/status within a reasonable time window.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate to /queue-status to look for a public queue status page and check for 'Position' text\n        await page.goto(\"http://localhost:3000/queue-status\", wait_until=\"commit\", timeout=10000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Position').first).to_be_visible(timeout=3000)\n        await expect(frame.locator('text=Now serving').first).to_be_visible(timeout=3000)\n        await expect(frame.locator('text=Now serving').first).to_be_visible(timeout=3000)\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "TEST FAILURE\n\nASSERTIONS:\n- Queue status page at /queue-status loaded but contains 0 interactive elements and no visible \"Position\" text.\n- The page appears blank in the screenshot and the SPA did not render any UI or dynamic elements.\n- No public queue-status link with a queue id was found or reachable on the site to monitor real-time updates.\n- Unable to observe any real-time position/status updates because the required UI elements to display queue position or \"Now serving\" are absent.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/54d844a8-4011-70b7-cc9a-127a66d438d2/1772297436202367//tmp/test_task/result.webm",
    "created": "2026-02-28T16:49:06.360Z",
    "modified": "2026-02-28T16:50:36.332Z"
  },
  {
    "projectId": "a012f828-a974-4c5f-b691-e13c1f407366",
    "testId": "ee890e41-979b-4973-ab04-77d00b400eb4",
    "userId": "54d844a8-4011-70b7-cc9a-127a66d438d2",
    "title": "TC032-When at the front, page shows 'Now serving' state",
    "description": "Verifies that when the client reaches the front of the queue, the page shows a clear 'Now serving' status.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate to a public queue status path on the same host, e.g. /queue-status/1, to check for 'Now serving' and position text.\n        await page.goto(\"http://localhost:3000/queue-status/1\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate to http://localhost:3000/queue-status/2 and check the page for the texts: 'Now serving', 'Position', '1' or '0', 'Estimated', 'min'.\n        await page.goto(\"http://localhost:3000/queue-status/2\", wait_until=\"commit\", timeout=10000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Now serving').first).to_be_visible(timeout=3000)\n        await expect(frame.locator('text=Position').first).to_be_visible(timeout=3000)\n        await expect(frame.locator('text=1').first).to_be_visible(timeout=3000)\n        await expect(frame.locator('text=Estimated').first).to_be_visible(timeout=3000)\n        await expect(frame.locator('text=min').first).to_be_visible(timeout=3000)\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "TEST FAILURE\n\nASSERTIONS:\n- Queue status page did not display the text 'Now serving'; visible UI shows service selection cards ('Barbearia', 'Beauty & Spa') instead.\n- The text 'Position' was not found on the page.\n- The page did not show 'Estimated' or the time unit 'min'.\n- No numeric indicator '1' or '0' (to indicate front-of-queue) was visible on the page.\n- The interactive elements present are service selection buttons, not queue-status indicators, indicating the queue-front feature or its rendering is missing or not reachable on the tested pages.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/54d844a8-4011-70b7-cc9a-127a66d438d2/1772297492587848//tmp/test_task/result.webm",
    "created": "2026-02-28T16:49:06.365Z",
    "modified": "2026-02-28T16:51:32.697Z"
  },
  {
    "projectId": "a012f828-a974-4c5f-b691-e13c1f407366",
    "testId": "5d76dd25-993e-4cc7-adba-6a9be0f9b02b",
    "userId": "54d844a8-4011-70b7-cc9a-127a66d438d2",
    "title": "TC033-Invalid queue link shows 'queue not found' error message",
    "description": "Verifies that an invalid queue status URL shows a clear error message and does not show queue details.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate to http://localhost:3000/queue-status/invalid to check the error message and absence of queue details.\n        await page.goto(\"http://localhost:3000/queue-status/invalid\", wait_until=\"commit\", timeout=10000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=queue not found').first).to_be_visible(timeout=3000)\n        await expect(frame.locator('text=Position').first).not_to_be_visible(timeout=3000)\n        await expect(frame.locator('text=Estimated').first).not_to_be_visible(timeout=3000)\n        assert '/queue-status/' in frame.url\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "TEST FAILURE\n\nASSERTIONS:\n- 'queue not found' message not found on the /queue-status/invalid page.\n- Page content did not render (blank page / no interactive elements) preventing display of expected queue details.\n- No interactive elements present on the page (0 interactive elements).",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/54d844a8-4011-70b7-cc9a-127a66d438d2/1772297437512164//tmp/test_task/result.webm",
    "created": "2026-02-28T16:49:06.371Z",
    "modified": "2026-02-28T16:50:37.638Z"
  }
]
