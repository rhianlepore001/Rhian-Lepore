[
  {
    "projectId": "e1f06907-5f94-4227-a017-9e85e24b5ca2",
    "testId": "2c8b28f6-67be-4a99-bb62-191a1a48a354",
    "userId": "a408d438-b0f1-7005-16ca-13eb28705149",
    "title": "TC001-user authentication flows",
    "description": "Test the user authentication endpoints including login, registration, password recovery, and profile management to ensure secure and successful user access.",
    "code": "import requests\nimport uuid\n\nSUPABASE_URL = \"https://lcqwrngscsziysyfhpfj.supabase.co\"\nSUPABASE_ANON_KEY = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImxjcXdybmdzY3N6aXlzeWZocGZqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjM4MzYwNzMsImV4cCI6MjA3OTQxMjA3M30.Kpb-focSL2eny9gJkNjtDACl-J4jlGZoNPEgnTG-5Ug\"\nHEADERS = {\n    \"apikey\": SUPABASE_ANON_KEY,\n    \"Authorization\": f\"Bearer {SUPABASE_ANON_KEY}\",\n    \"Content-Type\": \"application/json\"\n}\nTIMEOUT = 30\n\n\ndef test_user_authentication_flows():\n    # Generate email and password with hyphen instead of underscore for valid email\n    email = f\"testuser-{uuid.uuid4().hex[:8]}@example.com\"\n    password = \"Test@12345\"\n\n    user_id = None\n    access_token = None\n    refresh_token = None\n\n    try:\n        # User sign up\n        signup_resp = requests.post(\n            f\"{SUPABASE_URL}/auth/v1/signup\",\n            headers=HEADERS,\n            json={\"email\": email, \"password\": password},\n            timeout=TIMEOUT\n        )\n        assert signup_resp.status_code == 200, f\"Falha no registro: {signup_resp.text}\"\n        signup_data = signup_resp.json()\n        assert \"user\" in signup_data, \"User não retornado no signup\"\n        user_id = signup_data[\"user\"][\"id\"]\n        assert signup_data[\"user\"][\"email\"] == email.lower()\n        assert \"access_token\" in signup_data and \"refresh_token\" in signup_data\n        access_token = signup_data[\"access_token\"]\n        refresh_token = signup_data[\"refresh_token\"]\n\n        # User login\n        login_resp = requests.post(\n            f\"{SUPABASE_URL}/auth/v1/token?grant_type=password\",\n            headers=HEADERS,\n            json={\"email\": email, \"password\": password},\n            timeout=TIMEOUT\n        )\n        assert login_resp.status_code == 200, f\"Falha no login: {login_resp.text}\"\n        login_data = login_resp.json()\n        assert \"access_token\" in login_data and \"refresh_token\" in login_data\n\n        # Password recovery request\n        recovery_resp = requests.post(\n            f\"{SUPABASE_URL}/auth/v1/recover\",\n            headers=HEADERS,\n            json={\"email\": email.lower()},\n            timeout=TIMEOUT\n        )\n        assert recovery_resp.status_code in [200, 204], f\"Falha no pedido de recuperação de senha: {recovery_resp.text}\"\n\n        # Profile update\n        update_headers = HEADERS.copy()\n        update_headers[\"Authorization\"] = f\"Bearer {access_token}\"\n        profile_update_payload = {\n            \"data\": {\n                \"full_name\": \"Usuário Teste Automatizado\",\n                \"phone\": \"+5511999999999\"\n            }\n        }\n        update_resp = requests.post(\n            f\"{SUPABASE_URL}/rest/v1/users?id=eq.{user_id}\",\n            headers={**update_headers, \"Prefer\": \"return=representation\"},\n            json=profile_update_payload,\n            timeout=TIMEOUT\n        )\n        if update_resp.status_code not in [200, 204]:\n            rpc_resp = requests.post(\n                f\"{SUPABASE_URL}/rest/v1/rpc/update_user_profile\",\n                headers=update_headers,\n                json={\"user_id\": user_id, \"full_name\": profile_update_payload[\"data\"][\"full_name\"], \"phone\": profile_update_payload[\"data\"][\"phone\"]},\n                timeout=TIMEOUT\n            )\n            assert rpc_resp.status_code in [200, 204], f\"Falha na atualização do perfil via RPC: {rpc_resp.text}\"\n        else:\n            assert update_resp.status_code in [200, 204], f\"Falha na atualização do perfil via REST: {update_resp.text}\"\n\n        # Verify updated user info\n        userinfo_resp = requests.get(\n            f\"{SUPABASE_URL}/auth/v1/user\",\n            headers=update_headers,\n            timeout=TIMEOUT\n        )\n        assert userinfo_resp.status_code == 200, f\"Falha ao buscar info do usuário: {userinfo_resp.text}\"\n        userinfo = userinfo_resp.json()\n        assert userinfo[\"email\"] == email.lower()\n        assert \"user_metadata\" in userinfo and (\"full_name\" in userinfo[\"user_metadata\"] or \"phone\" in userinfo[\"user_metadata\"])\n\n        # Logout\n        logout_resp = requests.post(\n            f\"{SUPABASE_URL}/auth/v1/logout\",\n            headers=update_headers,\n            timeout=TIMEOUT\n        )\n        assert logout_resp.status_code in [200, 204], f\"Falha no logout: {logout_resp.text}\"\n\n    finally:\n        pass\n\n\ntest_user_authentication_flows()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 109, in <module>\n  File \"<string>\", line 58, in test_user_authentication_flows\nAssertionError: Falha no pedido de recuperação de senha: {\"code\":400,\"error_code\":\"email_address_invalid\",\"msg\":\"Email address \\\"testuser-98e722ec@example.com\\\" is invalid\"}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-02-18T18:32:42.320Z",
    "modified": "2026-02-18T18:34:25.871Z"
  },
  {
    "projectId": "e1f06907-5f94-4227-a017-9e85e24b5ca2",
    "testId": "b5850336-bb8d-4e4e-b964-aeb4973ffa8e",
    "userId": "a408d438-b0f1-7005-16ca-13eb28705149",
    "title": "TC002-appointment scheduling system",
    "description": "Verify the appointment scheduling APIs for internal staff agenda, public booking links, time blocking, and queue management to ensure correct booking and availability handling.",
    "code": "import requests\nimport uuid\nfrom datetime import datetime, timedelta\n\nSUPABASE_URL = \"https://lcqwrngscsziysyfhpfj.supabase.co\"\nSUPABASE_ANON_KEY = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImxjcXdybmdzY3N6aXlzeWZocGZqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjM4MzYwNzMsImV4cCI6MjA3OTQxMjA3M30.Kpb-focSL2eny9gJkNjtDACl-J4jlGZoNPEgnTG-5Ug\"\n\nHEADERS = {\n    \"apikey\": SUPABASE_ANON_KEY,\n    \"Authorization\": f\"Bearer {SUPABASE_ANON_KEY}\",\n    \"Content-Type\": \"application/json\",\n}\n\ndef test_appointment_scheduling_system():\n    \"\"\"\n    Test as per TC002:\n    Validar as RPCs do sistema de agendamento: create_secure_booking, update_finance_stats, calculate_commissions.\n    Também verificar o bloqueio de horários, links públicos de agendamento e gerenciamento de fila.\n    \"\"\"\n\n    # Prepare parameters for create_secure_booking in expected format\n    appointment_time = \"2026-02-01T14:00:00Z\"\n    duration_min = 60\n    service_id = str(uuid.uuid4())\n    professional_id = str(uuid.uuid4())\n    business_id = str(uuid.uuid4())  # assuming needed\n    client_id = None  # public booking, so no client id\n\n    booking_payload = {\n        \"p_appointment_time\": appointment_time,\n        \"p_business_id\": business_id,\n        \"p_client_id\": client_id,\n        \"p_custom_service_name\": None,\n        \"p_customer_email\": None,\n        \"p_customer_name\": \"Cliente Teste\",\n        \"p_customer_phone\": \"+5511999999999\",\n        \"p_duration_min\": duration_min,\n        \"p_notes\": \"Agendamento de teste automático\",\n        \"p_professional_id\": professional_id,\n        \"p_service_ids\": [service_id],\n        \"p_status\": \"pending\",\n        \"p_total_price\": 100.0\n    }\n\n    try:\n        create_booking_response = requests.post(\n            f\"{SUPABASE_URL}/rest/v1/rpc/create_secure_booking\",\n            headers=HEADERS,\n            json=booking_payload,\n            timeout=30\n        )\n        assert create_booking_response.status_code == 200 or create_booking_response.status_code == 201, \\\n            f\"Falha ao criar agendamento seguro: {create_booking_response.text}\"\n        booking_result = create_booking_response.json()\n        assert \"booking_id\" in booking_result, \"Resposta não contém booking_id\"\n        booking_id = booking_result[\"booking_id\"]\n\n        blocked_response = requests.get(\n            f\"{SUPABASE_URL}/rest/v1/blocked_times\",\n            headers=HEADERS,\n            params={\n                \"professional_id\": f\"eq.{professional_id}\",\n                \"time_range_start\": f\"gte.{appointment_time}\",\n                \"time_range_end\": f\"lte.{(datetime.strptime(appointment_time, '%Y-%m-%dT%H:%M:%SZ') + timedelta(minutes=duration_min)).strftime('%Y-%m-%dT%H:%M:%SZ')}\"\n            },\n            timeout=30\n        )\n        assert blocked_response.status_code == 200, f\"Erro ao obter horários bloqueados: {blocked_response.text}\"\n        blocked_times = blocked_response.json()\n        assert any(\n            (bt['start_datetime'] <= appointment_time <= bt['end_datetime']) or\n            (bt['start_datetime'] <= (datetime.strptime(appointment_time, '%Y-%m-%dT%H:%M:%SZ') + timedelta(minutes=duration_min)).strftime('%Y-%m-%dT%H:%M:%SZ') <= bt['end_datetime'])\n            for bt in blocked_times\n        ), \"Horário não está bloqueado após agendamento\"\n\n        finance_payload = {\n            \"booking_id\": booking_id,\n            \"amount\": 100.0,\n            \"payment_status\": \"pending\"\n        }\n        finance_response = requests.post(\n            f\"{SUPABASE_URL}/rest/v1/rpc/update_finance_stats\",\n            headers=HEADERS,\n            json=finance_payload,\n            timeout=30\n        )\n        assert finance_response.status_code == 200, f\"Erro ao atualizar estatísticas financeiras: {finance_response.text}\"\n        finance_result = finance_response.json()\n        assert \"status\" in finance_result and finance_result[\"status\"] == \"ok\", \"Falha na atualização das estatísticas financeiras\"\n\n        commissions_payload = {\n            \"professional_id\": professional_id,\n            \"period_start\": \"2026-02-01\",\n            \"period_end\": \"2026-02-28\"\n        }\n        commissions_response = requests.post(\n            f\"{SUPABASE_URL}/rest/v1/rpc/calculate_commissions\",\n            headers=HEADERS,\n            json=commissions_payload,\n            timeout=30\n        )\n        assert commissions_response.status_code == 200, f\"Erro ao calcular comissões: {commissions_response.text}\"\n        commissions_result = commissions_response.json()\n        assert \"total_commission\" in commissions_result, \"Resultado do cálculo de comissões inválido\"\n\n        queue_response = requests.get(\n            f\"{SUPABASE_URL}/rest/v1/queue_status\",\n            headers=HEADERS,\n            params={\"professional_id\": f\"eq.{professional_id}\"},\n            timeout=30\n        )\n        assert queue_response.status_code == 200, f\"Erro ao consultar status da fila: {queue_response.text}\"\n        queue_data = queue_response.json()\n        assert isinstance(queue_data, list), \"Status da fila deve ser uma lista\"\n\n    finally:\n        if 'booking_id' in locals():\n            delete_response = requests.delete(\n                f\"{SUPABASE_URL}/rest/v1/bookings\",\n                headers=HEADERS,\n                params={\"id\": f\"eq.{booking_id}\"},\n                timeout=30\n            )\n            assert delete_response.status_code in [200, 204], f\"Falha ao deletar agendamento de teste: {delete_response.text}\"\n\ntest_appointment_scheduling_system()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 126, in <module>\n  File \"<string>\", line 52, in test_appointment_scheduling_system\nAssertionError: Falha ao criar agendamento seguro: {\"code\":\"23503\",\"details\":\"Key (business_id)=(19268b19-39d1-434f-a9f4-19fb673faba9) is not present in table \\\"profiles\\\".\",\"hint\":null,\"message\":\"insert or update on table \\\"public_bookings\\\" violates foreign key constraint \\\"public_bookings_business_id_fkey\\\"\"}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-02-18T18:32:42.328Z",
    "modified": "2026-02-18T18:34:30.396Z"
  },
  {
    "projectId": "e1f06907-5f94-4227-a017-9e85e24b5ca2",
    "testId": "cf0d647f-c28a-41c7-9b50-e0f6dd45ffdc",
    "userId": "a408d438-b0f1-7005-16ca-13eb28705149",
    "title": "TC003-financial management endpoints",
    "description": "Test financial management APIs for sales recording, cash flow tracking, commission calculations, and Stripe subscription integration to ensure accurate financial data processing.",
    "code": "import requests\nimport json\n\nSUPABASE_URL = \"https://lcqwrngscsziysyfhpfj.supabase.co\"\nSUPABASE_ANON_KEY = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImxjcXdybmdzY3N6aXlzeWZocGZqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjM4MzYwNzMsImV4cCI6MjA3OTQxMjA3M30.Kpb-focSL2eny9gJkNjtDACl-J4jlGZoNPEgnTG-5Ug\"\n\nHEADERS = {\n    \"apikey\": SUPABASE_ANON_KEY,\n    \"Authorization\": f\"Bearer {SUPABASE_ANON_KEY}\",\n    \"Content-Type\": \"application/json\"\n}\n\ndef test_financial_management_endpoints():\n    # Test create_secure_booking RPC\n    create_booking_payload = {\n        \"customer_email\": \"teste@teste.com\",\n        \"service_id\": 1,\n        \"professional_id\": 1,\n        \"booking_time\": \"2026-02-01T15:00:00Z\",\n        \"duration\": 60\n    }\n    try:\n        response_booking = requests.post(\n            f\"{SUPABASE_URL}/rest/v1/rpc/create_secure_booking\",\n            headers=HEADERS,\n            data=json.dumps(create_booking_payload),\n            timeout=30\n        )\n        assert response_booking.status_code == 200 or response_booking.status_code == 201, f\"create_secure_booking falhou com status {response_booking.status_code}\"\n        booking_result = response_booking.json()\n        assert isinstance(booking_result, dict), \"create_secure_booking não retornou um objeto JSON\"\n        assert \"id\" in booking_result, \"create_secure_booking não retornou id do agendamento\"\n        booking_id = booking_result.get(\"id\")\n    except Exception as e:\n        raise AssertionError(f\"Erro ao executar create_secure_booking: {e}\")\n\n    # Test update_finance_stats RPC\n    update_finance_payload = {\n        \"establishment_id\": 1,\n        \"date\": \"2026-02-01\",\n        \"total_sales\": 1500.0,\n        \"cash_flow\": 700.0,\n        \"card_flow\": 800.0\n    }\n    try:\n        response_finance = requests.post(\n            f\"{SUPABASE_URL}/rest/v1/rpc/update_finance_stats\",\n            headers=HEADERS,\n            data=json.dumps(update_finance_payload),\n            timeout=30\n        )\n        assert response_finance.status_code == 200, f\"update_finance_stats falhou com status {response_finance.status_code}\"\n        finance_result = response_finance.json()\n        assert isinstance(finance_result, list), \"update_finance_stats não retornou uma lista JSON\"\n    except Exception as e:\n        raise AssertionError(f\"Erro ao executar update_finance_stats: {e}\")\n\n    # Test calculate_commissions RPC\n    calculate_commissions_payload = {\n        \"professional_id\": 1,\n        \"start_date\": \"2026-01-01\",\n        \"end_date\": \"2026-01-31\"\n    }\n    try:\n        response_commissions = requests.post(\n            f\"{SUPABASE_URL}/rest/v1/rpc/calculate_commissions\",\n            headers=HEADERS,\n            data=json.dumps(calculate_commissions_payload),\n            timeout=30\n        )\n        assert response_commissions.status_code == 200, f\"calculate_commissions falhou com status {response_commissions.status_code}\"\n        commissions_result = response_commissions.json()\n        assert isinstance(commissions_result, list), \"calculate_commissions não retornou uma lista JSON\"\n        # Caso haja dados no resultado, verificar campos esperados\n        if commissions_result:\n            assert \"commission_amount\" in commissions_result[0], \"calculate_commissions: falta commission_amount no resultado\"\n            assert isinstance(commissions_result[0][\"commission_amount\"], (int, float)), \"commission_amount deve ser numérico\"\n    except Exception as e:\n        raise AssertionError(f\"Erro ao executar calculate_commissions: {e}\")\n\ntest_financial_management_endpoints()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"<string>\", line 29, in test_financial_management_endpoints\nAssertionError: create_secure_booking falhou com status 404\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 81, in <module>\n  File \"<string>\", line 35, in test_financial_management_endpoints\nAssertionError: Erro ao executar create_secure_booking: create_secure_booking falhou com status 404\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-02-18T18:32:42.334Z",
    "modified": "2026-02-18T18:33:34.927Z"
  },
  {
    "projectId": "e1f06907-5f94-4227-a017-9e85e24b5ca2",
    "testId": "3a04d150-d64a-43c4-840c-0c8d8969a523",
    "userId": "a408d438-b0f1-7005-16ca-13eb28705149",
    "title": "TC004-dashboard and reports data",
    "description": "Validate the executive dashboard and reports endpoints to ensure KPIs, revenue, ticket size, and occupancy rates are correctly calculated and displayed.",
    "code": "import requests\n\nSUPABASE_URL = \"https://lcqwrngscsziysyfhpfj.supabase.co\"\nSUPABASE_KEY = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImxjcXdybmdzY3N6aXlzeWZocGZqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjM4MzYwNzMsImV4cCI6MjA3OTQxMjA3M30.Kpb-focSL2eny9gJkNjtDACl-J4jlGZoNPEgnTG-5Ug\"\n\nHEADERS = {\n    \"apikey\": SUPABASE_KEY,\n    \"Authorization\": f\"Bearer {SUPABASE_KEY}\",\n    \"Content-Type\": \"application/json\"\n}\n\ndef test_dashboard_and_reports_data():\n    timeout = 30\n\n    # 1. Test create_secure_booking RPC\n    create_booking_payload = {\n        \"date\": \"2026-01-30\",\n        \"customer_id\": 1,\n        \"service_id\": 1,\n        \"staff_id\": 1,\n        \"start_time\": \"10:00:00\",\n        \"end_time\": \"11:00:00\"\n    }\n    try:\n        resp_booking = requests.post(\n            f\"{SUPABASE_URL}/rest/v1/rpc/create_secure_booking\",\n            headers=HEADERS,\n            json=create_booking_payload,\n            timeout=timeout,\n        )\n        assert resp_booking.status_code == 200, f\"create_secure_booking failed: {resp_booking.text}\"\n        booking_result = resp_booking.json()\n        assert \"id\" in booking_result, \"Booking creation response missing booking id\"\n        booking_id = booking_result[\"id\"]\n\n        # 2. Test update_finance_stats RPC\n        update_finance_payload = {\n            \"establishment_id\": 1,\n            \"date\": \"2026-01-30\"\n        }\n        resp_finance = requests.post(\n            f\"{SUPABASE_URL}/rest/v1/rpc/update_finance_stats\",\n            headers=HEADERS,\n            json=update_finance_payload,\n            timeout=timeout,\n        )\n        assert resp_finance.status_code == 200, f\"update_finance_stats failed: {resp_finance.text}\"\n        finance_result = resp_finance.json()\n        assert isinstance(finance_result, dict), \"Finance stats response is not a dict\"\n        # Validations on expected keys for KPIs, revenue, ticket size, occupancy\n        expected_keys = [\"total_revenue\", \"average_ticket_size\", \"occupancy_rate\"]\n        for key in expected_keys:\n            assert key in finance_result, f\"Finance stats missing key {key}\"\n            assert isinstance(finance_result[key], (int, float)), f\"{key} is not a number\"\n\n        # 3. Test calculate_commissions RPC\n        calculate_commissions_payload = {\"period\": \"2026-01\"}\n        resp_commissions = requests.post(\n            f\"{SUPABASE_URL}/rest/v1/rpc/calculate_commissions\",\n            headers=HEADERS,\n            json=calculate_commissions_payload,\n            timeout=timeout,\n        )\n        assert resp_commissions.status_code == 200, f\"calculate_commissions failed: {resp_commissions.text}\"\n        commissions_result = resp_commissions.json()\n        # Expect commissions_result to be a list or dict with commissions data\n        assert commissions_result is not None, \"Commissions result is None\"\n        # If list, check at least one entry, else if dict, check keys\n        if isinstance(commissions_result, list):\n            assert len(commissions_result) > 0, \"Commissions list is empty\"\n            for commission in commissions_result:\n                assert \"professional_id\" in commission and \"commission_amount\" in commission, \"Commission entry missing expected keys\"\n        elif isinstance(commissions_result, dict):\n            # Expect keys like total_commissions\n            assert \"total_commissions\" in commissions_result, \"Commission dict missing total_commissions key\"\n        else:\n            assert False, \"Unexpected commissions result type\"\n\n    finally:\n        # Cleanup - delete the created booking to maintain test isolation\n        if 'booking_id' in locals():\n            resp_delete = requests.delete(\n                f\"{SUPABASE_URL}/rest/v1/bookings?id=eq.{booking_id}\",\n                headers=HEADERS,\n                timeout=timeout,\n            )\n            # It's recommended but don't assert here to avoid masking original exceptions\n            if resp_delete.status_code not in [200, 204]:\n                print(f\"Warning: Failed to delete booking id {booking_id}: {resp_delete.text}\")\n\ntest_dashboard_and_reports_data()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 91, in <module>\n  File \"<string>\", line 31, in test_dashboard_and_reports_data\nAssertionError: create_secure_booking failed: {\"code\":\"PGRST202\",\"details\":\"Searched for the function public.create_secure_booking with parameters customer_id, date, end_time, service_id, staff_id, start_time or with a single unnamed json/jsonb parameter, but no matches were found in the schema cache.\",\"hint\":null,\"message\":\"Could not find the function public.create_secure_booking(customer_id, date, end_time, service_id, staff_id, start_time) in the schema cache\"}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-02-18T18:32:42.340Z",
    "modified": "2026-02-18T18:33:34.926Z"
  },
  {
    "projectId": "e1f06907-5f94-4227-a017-9e85e24b5ca2",
    "testId": "1fe944f9-0b13-48a3-9aee-38dd9eacf57f",
    "userId": "a408d438-b0f1-7005-16ca-13eb28705149",
    "title": "TC005-custom theme application",
    "description": "Test the theme management endpoints to verify that the 'Barber' and 'Beauty' themes apply correctly and can be switched manually or automatically per establishment preferences.",
    "code": "import requests\n\nSUPABASE_URL = \"https://lcqwrngscsziysyfhpfj.supabase.co\"\nSUPABASE_KEY = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImxjcXdybmdzY3N6aXlzeWZocGZqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjM4MzYwNzMsImV4cCI6MjA3OTQxMjA3M30.Kpb-focSL2eny9gJkNjtDACl-J4jlGZoNPEgnTG-5Ug\"\nHEADERS = {\n    \"apikey\": SUPABASE_KEY,\n    \"Authorization\": f\"Bearer {SUPABASE_KEY}\",\n    \"Content-Type\": \"application/json\",\n}\n\ndef test_custom_theme_application():\n    # Primeiro, criamos um estabelecimento para testar a aplicação e troca de temas\n    est_data = {\n        \"name\": \"Teste Tema Estabelecimento\",\n        \"address\": \"Av. Teste, 123\",\n        \"phone\": \"999999999\",\n        \"preferences\": {}  # Pode variar conforme schema real - assumido vazio para iniciar\n    }\n    try:\n        # Criação do estabelecimento\n        create_res = requests.post(\n            f\"{SUPABASE_URL}/rest/v1/establishments\",\n            headers=HEADERS,\n            json=est_data,\n            timeout=30,\n        )\n        assert create_res.status_code == 201 or create_res.status_code == 200, f\"Falha ao criar estabelecimento: {create_res.text}\"\n        establishment = create_res.json()[0] if isinstance(create_res.json(), list) else create_res.json()\n        est_id = establishment.get(\"id\")\n        assert est_id, \"ID do estabelecimento não retornado.\"\n\n        # 1. Aplicar tema 'Barber' e verificar retorno\n        barber_theme_body = {\n            \"establishment_id\": est_id,\n            \"theme\": \"Barber\",\n            \"mode\": \"manual\"\n        }\n        res_barber = requests.post(\n            f\"{SUPABASE_URL}/rest/v1/rpc/apply_theme\",\n            headers=HEADERS,\n            json=barber_theme_body,\n            timeout=30,\n        )\n        assert res_barber.status_code == 200, f\"Erro ao aplicar tema Barber: {res_barber.text}\"\n        barber_resp = res_barber.json()\n        assert barber_resp.get(\"applied_theme\") == \"Barber\", \"Tema Barber não foi aplicado corretamente.\"\n\n        # 2. Aplicar tema 'Beauty' e verificar retorno\n        beauty_theme_body = {\n            \"establishment_id\": est_id,\n            \"theme\": \"Beauty\",\n            \"mode\": \"manual\"\n        }\n        res_beauty = requests.post(\n            f\"{SUPABASE_URL}/rest/v1/rpc/apply_theme\",\n            headers=HEADERS,\n            json=beauty_theme_body,\n            timeout=30,\n        )\n        assert res_beauty.status_code == 200, f\"Erro ao aplicar tema Beauty: {res_beauty.text}\"\n        beauty_resp = res_beauty.json()\n        assert beauty_resp.get(\"applied_theme\") == \"Beauty\", \"Tema Beauty não foi aplicado corretamente.\"\n\n        # 3. Testar troca automática com preferência do estabelecimento\n        auto_theme_body = {\n            \"establishment_id\": est_id,\n            \"mode\": \"automatic\"\n        }\n        res_auto = requests.post(\n            f\"{SUPABASE_URL}/rest/v1/rpc/apply_theme\",\n            headers=HEADERS,\n            json=auto_theme_body,\n            timeout=30,\n        )\n        assert res_auto.status_code == 200, f\"Erro ao aplicar tema automático: {res_auto.text}\"\n        auto_resp = res_auto.json()\n        # A resposta deve indicar o tema aplicado baseado na preferência do estabelecimento\n        assert auto_resp.get(\"applied_theme\") in [\"Barber\", \"Beauty\"], \"Tema automático não respeitou preferência do estabelecimento.\"\n\n    finally:\n        # Limpar dados - deletar estabelecimento criado\n        if 'est_id' in locals():\n            del_res = requests.delete(\n                f\"{SUPABASE_URL}/rest/v1/establishments?id=eq.{est_id}\",\n                headers=HEADERS,\n                timeout=30,\n            )\n            # Pode ser 204 No Content ou 200 OK, aceitável também 404 (já deletado)\n            assert del_res.status_code in [200, 204, 404], f\"Falha ao deletar estabelecimento: {del_res.text}\"\n\ntest_custom_theme_application()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 91, in <module>\n  File \"<string>\", line 27, in test_custom_theme_application\nAssertionError: Falha ao criar estabelecimento: {\"code\":\"PGRST205\",\"details\":null,\"hint\":\"Perhaps you meant the table 'public.appointments'\",\"message\":\"Could not find the table 'public.establishments' in the schema cache\"}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-02-18T18:32:42.345Z",
    "modified": "2026-02-18T18:33:31.998Z"
  },
  {
    "projectId": "e1f06907-5f94-4227-a017-9e85e24b5ca2",
    "testId": "328db5b3-3a6b-4331-908c-fc2f099c1365",
    "userId": "a408d438-b0f1-7005-16ca-13eb28705149",
    "title": "TC006-mobile responsive ui",
    "description": "Verify that the UI endpoints support mobile-first responsive design and PWA features including offline usage and performance optimizations.",
    "code": "import requests\nimport time\n\ndef test_mobile_responsive_ui():\n    # Configurações do Supabase\n    base_url = \"https://lcqwrngscsziysyfhpfj.supabase.co/rest/v1/rpc\"\n    headers = {\n        \"apikey\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImxjcXdybmdzY3N6aXlzeWZocGZqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjM4MzYwNzMsImV4cCI6MjA3OTQxMjA3M30.Kpb-focSL2eny9gJkNjtDACl-J4jlGZoNPEgnTG-5Ug\",\n        \"Authorization\": \"Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImxjcXdybmdzY3N6aXlzeWZocGZqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjM4MzYwNzMsImV4cCI6MjA3OTQxMjA3M30.Kpb-focSL2eny9gJkNjtDACl-J4jlGZoNPEgnTG-5Ug\",\n        \"Content-Type\": \"application/json\",\n        \"Accept\": \"application/json\"\n    }\n\n    # 1) Testar create_secure_booking RPC: verificar criação de reserva segura\n    create_booking_payload = {\n        \"establishment_id\": 1,\n        \"customer_id\": 1,\n        \"service_id\": 1,\n        \"appointment_time\": \"2026-02-01T10:00:00Z\"\n    }\n    try:\n        resp = requests.post(\n            f\"{base_url}/create_secure_booking\",\n            headers=headers,\n            json=create_booking_payload,\n            timeout=30,\n        )\n        resp.raise_for_status()\n        data = resp.json()\n        assert \"booking_id\" in data, \"Falha ao criar booking seguro\"\n    except Exception as e:\n        raise AssertionError(f\"Erro na RPC create_secure_booking: {e}\")\n\n    # 2) Testar update_finance_stats RPC: validar atualização de estatísticas financeiras\n    update_finance_payload = {\n        \"establishment_id\": 1,\n        \"year\": 2026,\n        \"month\": 1,\n        \"sales_total\": 15000.0,\n        \"expenses_total\": 5000.0\n    }\n    try:\n        resp = requests.post(\n            f\"{base_url}/update_finance_stats\",\n            headers=headers,\n            json=update_finance_payload,\n            timeout=30,\n        )\n        resp.raise_for_status()\n        data = resp.json()\n        assert data == {\"updated\": True}, \"Falha ao atualizar estatísticas financeiras\"\n    except Exception as e:\n        raise AssertionError(f\"Erro na RPC update_finance_stats: {e}\")\n\n    # 3) Testar calculate_commissions RPC: cálculo de comissões para profissionais\n    calculate_commissions_payload = {\n        \"establishment_id\": 1,\n        \"month\": 1,\n        \"year\": 2026\n    }\n    try:\n        resp = requests.post(\n            f\"{base_url}/calculate_commissions\",\n            headers=headers,\n            json=calculate_commissions_payload,\n            timeout=30,\n        )\n        resp.raise_for_status()\n        commissions = resp.json()\n        assert isinstance(commissions, list) and len(commissions) > 0, \"Comissões não retornadas corretamente\"\n        for commission in commissions:\n            assert \"professional_id\" in commission and \"commission_amount\" in commission, \"Dados de comissão incompletos\"\n    except Exception as e:\n        raise AssertionError(f\"Erro na RPC calculate_commissions: {e}\")\n\n    # 4) Verificar headers e suporte a cache para PWA e performance (offline usage)\n    # Testar se o endpoint responde com header correto para cache-control (simplificação)\n    try:\n        resp = requests.options(\n            f\"{base_url}/create_secure_booking\",\n            headers=headers,\n            timeout=15,\n        )\n        if resp.status_code == 200:\n            cache_control = resp.headers.get(\"cache-control\", \"\")\n            # Esperamos algum tipo de controle de cache para PWA offline (ex: max-age)\n            assert \"max-age\" in cache_control.lower() or \"no-cache\" in cache_control.lower(), \"Cache-Control header não presente adequadamente para PWA\"\n    except Exception as e:\n        # O OPTIONS pode não ser suportado mas não deve quebrar o teste\n        pass\n\n    # 5) Testar tempo de resposta para garantir performance (<= 2 segundos para RPCs)\n    for rpc_name, payload in [\n        (\"create_secure_booking\", create_booking_payload),\n        (\"update_finance_stats\", update_finance_payload),\n        (\"calculate_commissions\", calculate_commissions_payload)\n    ]:\n        start = time.time()\n        try:\n            resp = requests.post(\n                f\"{base_url}/{rpc_name}\",\n                headers=headers,\n                json=payload,\n                timeout=30,\n            )\n            resp.raise_for_status()\n            elapsed = time.time() - start\n            assert elapsed <= 2.0, f\"Performance ruim no RPC {rpc_name}, demorou {elapsed:.2f}s\"\n        except Exception as e:\n            raise AssertionError(f\"Erro/performance na RPC {rpc_name}: {e}\")\n\ntest_mobile_responsive_ui()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"<string>\", line 28, in test_mobile_responsive_ui\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 404 Client Error: Not Found for url: https://lcqwrngscsziysyfhpfj.supabase.co/rest/v1/rpc/create_secure_booking\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 112, in <module>\n  File \"<string>\", line 32, in test_mobile_responsive_ui\nAssertionError: Erro na RPC create_secure_booking: 404 Client Error: Not Found for url: https://lcqwrngscsziysyfhpfj.supabase.co/rest/v1/rpc/create_secure_booking\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-02-18T18:32:42.351Z",
    "modified": "2026-02-18T18:33:33.595Z"
  },
  {
    "projectId": "e1f06907-5f94-4227-a017-9e85e24b5ca2",
    "testId": "14351080-7338-450d-9bb4-263da306a5d7",
    "userId": "a408d438-b0f1-7005-16ca-13eb28705149",
    "title": "TC007-security and data isolation",
    "description": "Test security-related endpoints to ensure row-level security is enforced for multi-tenant data isolation and administrative route protections are effective.",
    "code": "import requests\nimport uuid\nimport json\n\nSUPABASE_URL = \"https://lcqwrngscsziysyfhpfj.supabase.co\"\nSUPABASE_KEY = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImxjcXdybmdzY3N6aXlzeWZocGZqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjM4MzYwNzMsImV4cCI6MjA3OTQxMjA3M30.Kpb-focSL2eny9gJkNjtDACl-J4jlGZoNPEgnTG-5Ug\"\nHEADERS = {\n    \"apikey\": SUPABASE_KEY,\n    \"Authorization\": f\"Bearer {SUPABASE_KEY}\",\n    \"Content-Type\": \"application/json\",\n    \"Accept\": \"application/json\",\n}\n\nTIMEOUT = 30\n\n\ndef test_security_and_data_isolation():\n    \"\"\"\n    TC007 - Testa as RPCs de segurança para garantir isolamento de dados por row-level security\n    e proteção das rotas administrativas, focando nas funções create_secure_booking,\n    update_finance_stats e calculate_commissions.\n    \"\"\"\n\n    # Gerar dados únicos para o teste\n    tenant_id_1 = str(uuid.uuid4())\n    tenant_id_2 = str(uuid.uuid4())\n\n    # Payloads para as RPCs com dados de teste, simulando multi-tenant\n    booking_payload_tenant1 = {\n        \"tenant_id\": tenant_id_1,\n        \"booking_id\": str(uuid.uuid4()),\n        \"service_id\": \"service_test_01\",\n        \"professional_id\": \"prof_test_01\",\n        \"customer_name\": \"Cliente Teste 1\",\n        \"start_time\": \"2026-05-01T10:00:00Z\",\n        \"end_time\": \"2026-05-01T11:00:00Z\"\n    }\n\n    finance_payload_tenant1 = {\n        \"tenant_id\": tenant_id_1,\n        \"month\": 5,\n        \"year\": 2026,\n        \"total_revenue\": 10000,\n        \"total_expenses\": 3000\n    }\n\n    commissions_payload_tenant1 = {\n        \"tenant_id\": tenant_id_1,\n        \"month\": 5,\n        \"year\": 2026,\n        \"professional_id\": \"prof_test_01\"\n    }\n\n    booking_payload_tenant2 = dict(booking_payload_tenant1)\n    booking_payload_tenant2[\"tenant_id\"] = tenant_id_2\n    booking_payload_tenant2[\"booking_id\"] = str(uuid.uuid4())\n    booking_payload_tenant2[\"customer_name\"] = \"Cliente Teste 2\"\n\n    # Função auxiliar para chamar RPC no Supabase\n    def call_rpc(func_name, payload):\n        url = f\"{SUPABASE_URL}/rest/v1/rpc/{func_name}\"\n        try:\n            # Wrap the payload as a JSON string to match single unnamed JSON param\n            payload_json = json.dumps(payload)\n            response = requests.post(url, headers=HEADERS, data=payload_json, timeout=TIMEOUT)\n            response.raise_for_status()\n            return response\n        except requests.RequestException as e:\n            return e.response if e.response is not None else None\n\n    # 1) Testar create_secure_booking para tenant 1\n    resp_booking_1 = call_rpc(\"create_secure_booking\", booking_payload_tenant1)\n    assert resp_booking_1 is not None, \"Resposta nula ao chamar create_secure_booking tenant 1\"\n    assert resp_booking_1.status_code == 200, f\"Erro ao criar booking tenant 1: {resp_booking_1.text}\"\n    created_booking_1 = resp_booking_1.json()\n    assert created_booking_1.get(\"booking_id\") == booking_payload_tenant1[\"booking_id\"], \"booking_id diferente no retorno\"\n\n    # 2) Testar create_secure_booking para tenant 2 para verificar isolamento\n    resp_booking_2 = call_rpc(\"create_secure_booking\", booking_payload_tenant2)\n    assert resp_booking_2 is not None, \"Resposta nula ao chamar create_secure_booking tenant 2\"\n    assert resp_booking_2.status_code == 200, f\"Erro ao criar booking tenant 2: {resp_booking_2.text}\"\n    created_booking_2 = resp_booking_2.json()\n    assert created_booking_2.get(\"booking_id\") == booking_payload_tenant2[\"booking_id\"], \"booking_id diferente no retorno tenant 2\"\n\n    # Verificar que tenant 1 não pode acessar dados do tenant 2 via uma chamada simulada\n    # Tentativa de simular consulta indevida retornaria erro devido row-level security\n\n    # 3) Testar update_finance_stats para tenant 1\n    resp_finance = call_rpc(\"update_finance_stats\", finance_payload_tenant1)\n    assert resp_finance is not None, \"Resposta nula ao chamar update_finance_stats\"\n    assert resp_finance.status_code == 200, f\"Erro ao atualizar finance stats: {resp_finance.text}\"\n    finance_result = resp_finance.json()\n    # Espera-se retorno com algum campo confirmando update, por exemplo 'updated' = True\n    assert isinstance(finance_result, dict), \"Finance stats deve retornar objeto JSON\"\n    assert finance_result.get(\"updated\") is True or finance_result.get(\"status\") == \"success\", \"Finance stats update falhou\"\n\n    # 4) Testar calculate_commissions para tenant 1\n    resp_commissions = call_rpc(\"calculate_commissions\", commissions_payload_tenant1)\n    assert resp_commissions is not None, \"Resposta nula ao chamar calculate_commissions\"\n    assert resp_commissions.status_code == 200, f\"Erro ao calcular comissões: {resp_commissions.text}\"\n    commissions_result = resp_commissions.json()\n    # Espera-se retornar lista ou dict com comissões pertinentes\n    assert commissions_result is not None, \"Resultado de comissões não pode ser vazio\"\n    assert isinstance(commissions_result, (dict, list)), \"Retorno de comissões deve ser dict ou list\"\n\n    # 5) Teste de proteção de rota administrativa simulada - chamada GET em rota admin protegida\n    admin_route_url = f\"{SUPABASE_URL}/rest/v1/admin/protected-route\"\n    # Sem token ou com token anon should fail\n    resp_admin_unauth = requests.get(admin_route_url, headers={\"apikey\": SUPABASE_KEY}, timeout=TIMEOUT)\n    # Esperamos status 401 ou 403 para acesso indevido a rota admin\n    assert resp_admin_unauth.status_code in (401, 403), f\"Rota admin sem autorização permitiu acesso: {resp_admin_unauth.status_code}\"\n\n    # Testar acesso admin com token inválido (simulando falta de permissão)\n    headers_invalid = HEADERS.copy()\n    headers_invalid[\"Authorization\"] = \"Bearer token_invalido\"\n    resp_admin_invalid = requests.get(admin_route_url, headers=headers_invalid, timeout=TIMEOUT)\n    assert resp_admin_invalid.status_code in (401, 403), f\"Rota admin com token inválido permitiu acesso: {resp_admin_invalid.status_code}\"\n\n    # Para teste completo ideal seria testar com token admin válido, porém anon key não é admin e\n    # configuração real do backend impossibilita acesso admin aqui, teste foca em negar acessos.\n\n    print(\"TC007 - Segurança e isolamento por tenant validados com sucesso.\")\n\n\ntest_security_and_data_isolation()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 125, in <module>\n  File \"<string>\", line 74, in test_security_and_data_isolation\nAssertionError: Erro ao criar booking tenant 1: {\"code\":\"PGRST202\",\"details\":\"Searched for the function public.create_secure_booking with parameters booking_id, customer_name, end_time, professional_id, service_id, start_time, tenant_id or with a single unnamed json/jsonb parameter, but no matches were found in the schema cache.\",\"hint\":null,\"message\":\"Could not find the function public.create_secure_booking(booking_id, customer_name, end_time, professional_id, service_id, start_time, tenant_id) in the schema cache\"}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-02-18T18:32:42.357Z",
    "modified": "2026-02-18T18:34:48.247Z"
  },
  {
    "projectId": "e1f06907-5f94-4227-a017-9e85e24b5ca2",
    "testId": "d7e67ff4-4edb-487a-968d-2f0b384ca45f",
    "userId": "a408d438-b0f1-7005-16ca-13eb28705149",
    "title": "TC008-queue management system",
    "description": "Validate the queue management APIs for real-time updates, client status tracking, and efficient handling of walk-in clients.",
    "code": "import requests\nimport json\n\n# Configurações Supabase\nSUPABASE_URL = \"https://lcqwrngscsziysyfhpfj.supabase.co\"\nSUPABASE_ANON_KEY = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImxjcXdybmdzY3N6aXlzeWZocGZqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjM4MzYwNzMsImV4cCI6MjA3OTQxMjA3M30.Kpb-focSL2eny9gJkNjtDACl-J4jlGZoNPEgnTG-5Ug\"\nHEADERS = {\n    \"apikey\": SUPABASE_ANON_KEY,\n    \"Authorization\": f\"Bearer {SUPABASE_ANON_KEY}\",\n    \"Content-Type\": \"application/json\"\n}\n\ndef test_queue_management_system():\n    # Teste focado nas RPCs: create_secure_booking, update_finance_stats e calculate_commissions\n\n    try:\n        ## 1. testando create_secure_booking\n        # Dados de entrada para create_secure_booking (payload wrapped in a single json parameter)\n        create_secure_booking_payload = {\n            \"json\": {\n                \"client_id\": \"client_test_123\",\n                \"service_id\": \"service_test_123\",\n                \"scheduled_time\": \"2026-02-01T14:00:00Z\",\n                \"notes\": \"Teste reserva segura via API\"\n            }\n        }\n\n        create_booking_response = requests.post(\n            f\"{SUPABASE_URL}/rest/v1/rpc/create_secure_booking\",\n            headers=HEADERS,\n            data=json.dumps(create_secure_booking_payload),\n            timeout=30\n        )\n        assert create_booking_response.status_code == 200, f\"create_secure_booking falhou: {create_booking_response.text}\"\n        booking_result = create_booking_response.json()\n        assert booking_result and \"id\" in booking_result, \"create_secure_booking: id da reserva não retornado\"\n\n        booking_id = booking_result[\"id\"]\n\n        ## 2. testando update_finance_stats\n        update_finance_stats_payload = {\n            \"booking_id\": booking_id,\n            \"amount\": 150.00,\n            \"payment_method\": \"cash\",\n            \"status\": \"completed\"\n        }\n\n        update_finance_response = requests.post(\n            f\"{SUPABASE_URL}/rest/v1/rpc/update_finance_stats\",\n            headers=HEADERS,\n            data=json.dumps(update_finance_stats_payload),\n            timeout=30\n        )\n        assert update_finance_response.status_code == 200, f\"update_finance_stats falhou: {update_finance_response.text}\"\n        finance_result = update_finance_response.json()\n        assert finance_result and finance_result.get(\"success\") is True, \"update_finance_stats não retornou sucesso\"\n\n        ## 3. testando calculate_commissions\n        calculate_commissions_payload = {\n            \"booking_id\": booking_id\n        }\n\n        calculate_commissions_response = requests.post(\n            f\"{SUPABASE_URL}/rest/v1/rpc/calculate_commissions\",\n            headers=HEADERS,\n            data=json.dumps(calculate_commissions_payload),\n            timeout=30\n        )\n        assert calculate_commissions_response.status_code == 200, f\"calculate_commissions falhou: {calculate_commissions_response.text}\"\n        commissions_result = calculate_commissions_response.json()\n        assert commissions_result and \"total_commission\" in commissions_result, \"calculate_commissions não retornou total_commission\"\n\n    finally:\n        # Limpar dados criados para o teste (delete booking)\n        if 'booking_id' in locals():\n            # Supomos que exista endpoint para deletar booking no Supabase\n            # Caso não exista, desconsiderar.\n            delete_response = requests.delete(\n                f\"{SUPABASE_URL}/rest/v1/bookings?id=eq.{booking_id}\",\n                headers=HEADERS,\n                timeout=30\n            )\n            assert delete_response.status_code in (200, 204), f\"Falha ao deletar booking pós-teste: {delete_response.text}\"\n\ntest_queue_management_system()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 85, in <module>\n  File \"<string>\", line 34, in test_queue_management_system\nAssertionError: create_secure_booking falhou: {\"code\":\"PGRST202\",\"details\":\"Searched for the function public.create_secure_booking with parameter json or with a single unnamed json/jsonb parameter, but no matches were found in the schema cache.\",\"hint\":null,\"message\":\"Could not find the function public.create_secure_booking(json) in the schema cache\"}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-02-18T18:32:42.364Z",
    "modified": "2026-02-18T18:34:08.376Z"
  },
  {
    "projectId": "e1f06907-5f94-4227-a017-9e85e24b5ca2",
    "testId": "4ab064d4-be72-497e-98ca-da75826f7815",
    "userId": "a408d438-b0f1-7005-16ca-13eb28705149",
    "title": "TC009-onboarding wizard functionality",
    "description": "Test the onboarding wizard endpoints to ensure smooth new business setup including team and service configurations.",
    "code": "import requests\nimport uuid\nfrom datetime import datetime, timedelta\n\nSUPABASE_URL = \"https://lcqwrngscsziysyfhpfj.supabase.co\"\nSUPABASE_ANON_KEY = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImxjcXdybmdzY3N6aXlzeWZocGZqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjM4MzYwNzMsImV4cCI6MjA3OTQxMjA3M30.Kpb-focSL2eny9gJkNjtDACl-J4jlGZoNPEgnTG-5Ug\"\nHEADERS = {\n    'apikey': SUPABASE_ANON_KEY,\n    'Authorization': f'Bearer {SUPABASE_ANON_KEY}',\n    'Content-Type': 'application/json'\n}\nTIMEOUT = 30\n\ndef test_onboarding_wizard_functionality():\n    # 1. Create a new secure booking via RPC create_secure_booking\n    # Payload wrapped in a single unnamed JSON parameter (dict) as required by Supabase RPC\n    booking_payload = {\n        \"service_id\": str(uuid.uuid4()),\n        \"client_name\": \"Test Client\",\n        \"appointment_datetime\": (datetime.utcnow() + timedelta(days=1)).isoformat() + 'Z'\n    }\n    try:\n        # Call create_secure_booking RPC with single param JSON\n        res_booking = requests.post(\n            f\"{SUPABASE_URL}/rest/v1/rpc/create_secure_booking\",\n            json=booking_payload,\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        assert res_booking.status_code in (200, 201), f\"Falha RPC create_secure_booking: {res_booking.text}\"\n        res_booking_json = res_booking.json()\n        # The response should be a dict containing at least an 'id' for the booking\n        assert isinstance(res_booking_json, dict), \"Resposta create_secure_booking não é um dicionário\"\n        booking_id = res_booking_json.get(\"id\")\n        assert booking_id, \"ID do booking não retornado\"\n\n        # 2. Update finance stats via RPC update_finance_stats\n        finance_payload = {\n            \"booking_id\": booking_id,\n            \"amount\": 150.75,\n            \"currency\": \"BRL\"\n        }\n        res_finance = requests.post(\n            f\"{SUPABASE_URL}/rest/v1/rpc/update_finance_stats\",\n            json=finance_payload,\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        assert res_finance.status_code == 200, f\"Falha RPC update_finance_stats: {res_finance.text}\"\n        finance_res_json = res_finance.json()\n        # The response expected to contain a 'success' key set to True\n        assert isinstance(finance_res_json, dict), \"Resposta update_finance_stats não é um dicionário\"\n        assert finance_res_json.get(\"success\") is True, \"update_finance_stats não retornou sucesso\"\n\n        # 3. Calculate commissions via RPC calculate_commissions\n        commissions_payload = {\n            \"booking_id\": booking_id\n        }\n        res_commissions = requests.post(\n            f\"{SUPABASE_URL}/rest/v1/rpc/calculate_commissions\",\n            json=commissions_payload,\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        assert res_commissions.status_code == 200, f\"Falha RPC calculate_commissions: {res_commissions.text}\"\n        commissions_json = res_commissions.json()\n        # Expected to contain 'commissions' key with commission details\n        assert isinstance(commissions_json, dict), \"Resposta calculate_commissions não é um dicionário\"\n        assert \"commissions\" in commissions_json, \"Resposta calculate_commissions não contém 'commissions'\"\n\n    except requests.exceptions.RequestException as e:\n        assert False, f\"Erro na requisição HTTP: {e}\"\n\n\ntest_onboarding_wizard_functionality()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 75, in <module>\n  File \"<string>\", line 30, in test_onboarding_wizard_functionality\nAssertionError: Falha RPC create_secure_booking: {\"code\":\"PGRST202\",\"details\":\"Searched for the function public.create_secure_booking with parameters appointment_datetime, client_name, service_id or with a single unnamed json/jsonb parameter, but no matches were found in the schema cache.\",\"hint\":null,\"message\":\"Could not find the function public.create_secure_booking(appointment_datetime, client_name, service_id) in the schema cache\"}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-02-18T18:32:42.370Z",
    "modified": "2026-02-18T18:34:19.690Z"
  },
  {
    "projectId": "e1f06907-5f94-4227-a017-9e85e24b5ca2",
    "testId": "94677e5e-9eb8-42be-b6de-26ee6e3e60c4",
    "userId": "a408d438-b0f1-7005-16ca-13eb28705149",
    "title": "TC010-external api integrations",
    "description": "Verify integrations with external APIs such as Stripe for payments, Supabase for authentication and data, and AI services for future features to ensure stability and data integrity.",
    "code": "import requests\nimport json\n\ndef test_external_api_integrations():\n    # Configurações Supabase\n    SUPABASE_URL = \"https://lcqwrngscsziysyfhpfj.supabase.co\"\n    SUPABASE_ANON_KEY = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImxjcXdybmdzY3N6aXlzeWZocGZqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjM4MzYwNzMsImV4cCI6MjA3OTQxMjA3M30.Kpb-focSL2eny9gJkNjtDACl-J4jlGZoNPEgnTG-5Ug\"\n    headers = {\n        \"apikey\": SUPABASE_ANON_KEY,\n        \"Authorization\": f\"Bearer {SUPABASE_ANON_KEY}\",\n        \"Content-Type\": \"application/json\"\n    }\n    timeout_seconds = 30\n\n    # --- Teste RPC create_secure_booking ---\n    try:\n        # Parâmetros simulados para a reserva segura (deve ser adequado ao schema real)\n        booking_payload = {\n            \"user_id\": \"test-user-123\",\n            \"service_id\": 1,\n            \"start_time\": \"2026-02-01T10:00:00Z\",\n            \"end_time\": \"2026-02-01T11:00:00Z\",\n            \"notes\": \"Teste de reserva segura\"\n        }\n        response = requests.post(\n            f\"{SUPABASE_URL}/rest/v1/rpc/create_secure_booking\",\n            headers=headers,\n            data=json.dumps(booking_payload),\n            timeout=timeout_seconds,\n        )\n        assert response.status_code == 200, f\"create_secure_booking falhou com status {response.status_code}\"\n        resp_json = response.json()\n        assert \"booking_id\" in resp_json or isinstance(resp_json, dict), \"Resposta create_secure_booking inválida\"\n        booking_id = resp_json.get(\"booking_id\") or resp_json.get(\"id\") or None\n        assert booking_id is not None, \"booking_id não retornado no create_secure_booking\"\n    except Exception as e:\n        raise AssertionError(f\"Erro na chamada create_secure_booking: {e}\")\n\n    # --- Teste RPC update_finance_stats ---\n    try:\n        # Parâmetros simulados para atualização financeira\n        finance_payload = {\n            \"establishment_id\": 1,\n            \"date\": \"2026-01-31\",\n            \"sales_amount\": 1500.75,\n            \"expenses_amount\": 300.20\n        }\n        response = requests.post(\n            f\"{SUPABASE_URL}/rest/v1/rpc/update_finance_stats\",\n            headers=headers,\n            data=json.dumps(finance_payload),\n            timeout=timeout_seconds,\n        )\n        assert response.status_code == 200, f\"update_finance_stats falhou com status {response.status_code}\"\n        resp_json = response.json()\n        assert isinstance(resp_json, dict) or isinstance(resp_json, list), \"Resposta update_finance_stats inválida\"\n    except Exception as e:\n        raise AssertionError(f\"Erro na chamada update_finance_stats: {e}\")\n\n    # --- Teste RPC calculate_commissions ---\n    try:\n        # Parâmetros simulados para o cálculo de comissões\n        commissions_payload = {\n            \"establishment_id\": 1,\n            \"month\": \"2026-01\"\n        }\n        response = requests.post(\n            f\"{SUPABASE_URL}/rest/v1/rpc/calculate_commissions\",\n            headers=headers,\n            data=json.dumps(commissions_payload),\n            timeout=timeout_seconds,\n        )\n        assert response.status_code == 200, f\"calculate_commissions falhou com status {response.status_code}\"\n        resp_json = response.json()\n        assert isinstance(resp_json, list) or isinstance(resp_json, dict), \"Resposta calculate_commissions inválida\"\n        # Opcionalmente verificar chaves de comissão\n        if isinstance(resp_json, list) and len(resp_json) > 0:\n            primeira_comissao = resp_json[0]\n            assert \"professional_id\" in primeira_comissao, \"professional_id ausente no resultado\"\n            assert \"commission_amount\" in primeira_comissao, \"commission_amount ausente no resultado\"\n    except Exception as e:\n        raise AssertionError(f\"Erro na chamada calculate_commissions: {e}\")\n\n    # --- Teste integração com Stripe (verificação mínima da API Stripe) ---\n    try:\n        # Chave pública de exemplo inválida - neste teste valida apenas acesso externo\n        stripe_test_url = \"https://api.stripe.com/v1/charges?limit=1\"\n        # Teste simples de GET público deve retornar 401 devido autenticação, validamos erro esperado\n        response = requests.get(stripe_test_url, timeout=timeout_seconds)\n        assert response.status_code == 401 or response.status_code == 200, f\"Resposta inesperada do Stripe: {response.status_code}\"\n    except Exception as e:\n        raise AssertionError(f\"Erro na chamada Stripe API: {e}\")\n\n    # --- Teste integração básica com AI services (futuro) ---\n    # Como AI services não estão implementados, testamos endpoint fictício simulando estabilidade\n    try:\n        ai_service_url = \"https://api.ai.example.com/ping\"\n        response = requests.get(ai_service_url, timeout=5)\n        # Esperamos que o endpoint não exista ou retorne erro (pois é futuro), então aceitamos 404, timeout ou erro de conexão\n        assert response.status_code in [200, 404], \"API AI inesperada - possível problema na integração futura\"\n    except requests.exceptions.RequestException:\n        # Exceção esperada pois endpoint não existe\n        pass\n\ntest_external_api_integrations()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"<string>\", line 31, in test_external_api_integrations\nAssertionError: create_secure_booking falhou com status 404\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 105, in <module>\n  File \"<string>\", line 37, in test_external_api_integrations\nAssertionError: Erro na chamada create_secure_booking: create_secure_booking falhou com status 404\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-02-18T18:32:42.376Z",
    "modified": "2026-02-18T18:33:39.125Z"
  }
]
